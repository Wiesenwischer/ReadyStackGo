# v0.6 Spezifikation: SQLite Migration & Multi-User Support

## Übersicht

Diese Version führt eine vollständige Domain-Driven Design (DDD) Architektur ein, migriert von JSON-Dateien zu SQLite und implementiert ein Multi-User-System mit rollenbasierter Zugriffskontrolle.

## Architektur

### Bounded Contexts

```
┌─────────────────────────────────────────────────────────────┐
│                    Identity & Access                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Tenant    │  │    User     │  │        Role         │  │
│  │ (Aggregate) │  │ (Aggregate) │  │    (Aggregate)      │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    Stack Management                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ Environment │  │ Deployment  │  │    StackSource      │  │
│  │ (Aggregate) │  │ (Aggregate) │  │    (Aggregate)      │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### Projektstruktur

```
src/
├── ReadyStackGo.Domain/
│   ├── Common/
│   │   ├── Entity.cs
│   │   ├── AggregateRoot.cs
│   │   ├── ValueObject.cs
│   │   ├── DomainEvent.cs
│   │   └── AssertionConcern.cs
│   │
│   ├── Identity/
│   │   ├── Aggregates/
│   │   │   ├── Tenant.cs
│   │   │   └── User.cs
│   │   ├── ValueObjects/
│   │   │   ├── TenantId.cs
│   │   │   ├── UserId.cs
│   │   │   ├── EmailAddress.cs
│   │   │   ├── HashedPassword.cs
│   │   │   └── Enablement.cs
│   │   ├── Events/
│   │   │   ├── TenantProvisioned.cs
│   │   │   ├── UserRegistered.cs
│   │   │   └── UserRoleAssigned.cs
│   │   ├── Services/
│   │   │   ├── TenantProvisioningService.cs
│   │   │   ├── AuthenticationService.cs
│   │   │   └── PasswordService.cs
│   │   └── Repositories/
│   │       ├── ITenantRepository.cs
│   │       └── IUserRepository.cs
│   │
│   ├── Access/
│   │   ├── Aggregates/
│   │   │   └── Role.cs
│   │   ├── ValueObjects/
│   │   │   ├── RoleId.cs
│   │   │   ├── Permission.cs
│   │   │   └── RoleAssignment.cs
│   │   ├── Events/
│   │   │   └── RoleProvisioned.cs
│   │   └── Repositories/
│   │       └── IRoleRepository.cs
│   │
│   └── StackManagement/
│       ├── Aggregates/
│       │   ├── Environment.cs
│       │   ├── Deployment.cs
│       │   └── StackSource.cs
│       ├── ValueObjects/
│       │   ├── EnvironmentId.cs
│       │   ├── DeploymentId.cs
│       │   ├── ConnectionConfig.cs
│       │   └── DeploymentStatus.cs
│       ├── Events/
│       │   ├── EnvironmentCreated.cs
│       │   ├── DeploymentStarted.cs
│       │   └── DeploymentCompleted.cs
│       └── Repositories/
│           ├── IEnvironmentRepository.cs
│           ├── IDeploymentRepository.cs
│           └── IStackSourceRepository.cs
│
├── ReadyStackGo.Application/
│   ├── Identity/
│   │   ├── Commands/
│   │   │   ├── ProvisionTenantCommand.cs
│   │   │   ├── RegisterUserCommand.cs
│   │   │   └── AssignRoleCommand.cs
│   │   ├── Queries/
│   │   │   ├── AuthenticateUserQuery.cs
│   │   │   └── GetUserPermissionsQuery.cs
│   │   └── IdentityApplicationService.cs
│   │
│   └── StackManagement/
│       ├── Commands/
│       │   ├── CreateEnvironmentCommand.cs
│       │   ├── DeployStackCommand.cs
│       │   └── RemoveDeploymentCommand.cs
│       └── StackManagementApplicationService.cs
│
├── ReadyStackGo.Infrastructure/
│   ├── Persistence/
│   │   ├── ReadyStackGoDbContext.cs
│   │   ├── Configurations/
│   │   │   ├── TenantConfiguration.cs
│   │   │   ├── UserConfiguration.cs
│   │   │   ├── RoleConfiguration.cs
│   │   │   ├── EnvironmentConfiguration.cs
│   │   │   └── DeploymentConfiguration.cs
│   │   └── Repositories/
│   │       ├── TenantRepository.cs
│   │       ├── UserRepository.cs
│   │       ├── RoleRepository.cs
│   │       ├── EnvironmentRepository.cs
│   │       └── DeploymentRepository.cs
│   │
│   └── Services/
│       ├── BCryptPasswordHasher.cs
│       └── JwtTokenService.cs
```

---

## Domain Model

### Identity Context

#### Tenant (Aggregate Root)

```csharp
public class Tenant : AggregateRoot<TenantId>
{
    public TenantId Id { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }
    public bool Active { get; private set; }
    public DateTime CreatedAt { get; private set; }

    // Factory method
    public static Tenant Provision(TenantId id, string name, string description)

    // Behaviors
    public void Activate()
    public void Deactivate()
    public void UpdateDescription(string description)
}
```

#### User (Aggregate Root)

```csharp
public class User : AggregateRoot<UserId>
{
    public UserId Id { get; private set; }
    public TenantId TenantId { get; private set; }
    public string Username { get; private set; }
    public EmailAddress Email { get; private set; }
    public HashedPassword Password { get; private set; }
    public Enablement Enablement { get; private set; }
    public DateTime CreatedAt { get; private set; }

    private readonly List<RoleAssignment> _roleAssignments;
    public IReadOnlyCollection<RoleAssignment> RoleAssignments => _roleAssignments.AsReadOnly();

    // Factory method
    public static User Register(UserId id, TenantId tenantId, string username,
                                EmailAddress email, HashedPassword password)

    // Behaviors
    public void AssignRole(RoleAssignment assignment)
    public void RevokeRole(RoleId roleId, ScopeType scopeType, string scopeId)
    public void ChangePassword(HashedPassword newPassword)
    public void Enable()
    public void Disable()
    public bool HasPermission(Permission permission, ScopeType scopeType, string scopeId)
}
```

#### Value Objects

```csharp
// TenantId
public sealed class TenantId : ValueObject
{
    public Guid Value { get; }
    public TenantId() => Value = Guid.NewGuid();
    public TenantId(Guid value) => Value = value;
    protected override IEnumerable<object> GetEqualityComponents() => [Value];
}

// UserId
public sealed class UserId : ValueObject
{
    public Guid Value { get; }
    public UserId() => Value = Guid.NewGuid();
    public UserId(Guid value) => Value = value;
    protected override IEnumerable<object> GetEqualityComponents() => [Value];
}

// EmailAddress
public sealed class EmailAddress : ValueObject
{
    public string Value { get; }

    public EmailAddress(string value)
    {
        AssertionConcern.AssertArgumentNotEmpty(value, "Email address is required.");
        AssertionConcern.AssertArgumentMatches(
            @"^[\w\.-]+@[\w\.-]+\.\w+$", value, "Invalid email format.");
        Value = value.ToLowerInvariant();
    }

    protected override IEnumerable<object> GetEqualityComponents() => [Value];
}

// HashedPassword
public sealed class HashedPassword : ValueObject
{
    public string Value { get; }

    private HashedPassword(string hashedValue) => Value = hashedValue;

    public static HashedPassword Create(string plainPassword, IPasswordHasher hasher)
    {
        AssertionConcern.AssertArgumentNotEmpty(plainPassword, "Password is required.");
        AssertionConcern.AssertArgumentLength(plainPassword, 8, 100,
            "Password must be between 8 and 100 characters.");
        return new HashedPassword(hasher.Hash(plainPassword));
    }

    public static HashedPassword FromHash(string hash) => new(hash);

    public bool Verify(string plainPassword, IPasswordHasher hasher)
        => hasher.Verify(plainPassword, Value);

    protected override IEnumerable<object> GetEqualityComponents() => [Value];
}

// Enablement
public sealed class Enablement : ValueObject
{
    public bool Enabled { get; }
    public DateTime? StartDate { get; }
    public DateTime? EndDate { get; }

    public static Enablement IndefiniteEnablement()
        => new(true, null, null);

    public static Enablement TemporaryEnablement(DateTime start, DateTime end)
        => new(true, start, end);

    public static Enablement Disabled()
        => new(false, null, null);

    public bool IsEnabled => Enabled && IsTimeValid();

    private bool IsTimeValid()
    {
        if (!StartDate.HasValue && !EndDate.HasValue) return true;
        var now = DateTime.UtcNow;
        return (!StartDate.HasValue || now >= StartDate)
            && (!EndDate.HasValue || now <= EndDate);
    }

    protected override IEnumerable<object> GetEqualityComponents()
        => [Enabled, StartDate, EndDate];
}

// RoleAssignment
public sealed class RoleAssignment : ValueObject
{
    public RoleId RoleId { get; }
    public ScopeType ScopeType { get; }
    public string? ScopeId { get; }  // null for Global scope
    public DateTime AssignedAt { get; }

    protected override IEnumerable<object> GetEqualityComponents()
        => [RoleId, ScopeType, ScopeId ?? ""];
}
```

### Access Context

#### Role (Aggregate Root)

```csharp
public class Role : AggregateRoot<RoleId>
{
    public RoleId Id { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }
    public ScopeType AllowedScope { get; private set; }

    private readonly List<Permission> _permissions;
    public IReadOnlyCollection<Permission> Permissions => _permissions.AsReadOnly();

    // Predefined roles
    public static Role SystemAdmin => new(
        new RoleId("system-admin"),
        "SystemAdmin",
        "Full system access",
        ScopeType.Global,
        Permission.All);

    public static Role OrganizationOwner => new(
        new RoleId("org-owner"),
        "OrganizationOwner",
        "Full access within organization",
        ScopeType.Organization,
        Permission.OrganizationAll);

    public static Role Operator => new(
        new RoleId("operator"),
        "Operator",
        "Can deploy and manage stacks",
        ScopeType.Organization | ScopeType.Environment,
        Permission.StackOperations);

    public static Role Viewer => new(
        new RoleId("viewer"),
        "Viewer",
        "Read-only access",
        ScopeType.Organization | ScopeType.Environment,
        Permission.ReadOnly);
}

// ScopeType
[Flags]
public enum ScopeType
{
    Global = 1,
    Organization = 2,
    Environment = 4
}

// Permission
public sealed class Permission : ValueObject
{
    public string Value { get; }

    // Predefined permissions
    public static Permission All => new("*");
    public static Permission OrganizationAll => new("organization:*");
    public static Permission StackOperations => new("stacks:deploy,stacks:start,stacks:stop,stacks:remove");
    public static Permission ReadOnly => new("read:*");

    // Specific permissions
    public static Permission UsersManage => new("users:manage");
    public static Permission EnvironmentsManage => new("environments:manage");
    public static Permission StacksDeploy => new("stacks:deploy");
    public static Permission StacksStart => new("stacks:start");
    public static Permission StacksStop => new("stacks:stop");
    public static Permission StacksRemove => new("stacks:remove");

    public bool Includes(Permission other)
    {
        if (Value == "*") return true;
        if (Value.EndsWith(":*"))
        {
            var prefix = Value[..^1];
            return other.Value.StartsWith(prefix);
        }
        return Value.Split(',').Contains(other.Value);
    }

    protected override IEnumerable<object> GetEqualityComponents() => [Value];
}
```

### Stack Management Context

#### Environment (Aggregate Root)

```csharp
public class Environment : AggregateRoot<EnvironmentId>
{
    public EnvironmentId Id { get; private set; }
    public TenantId TenantId { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }
    public EnvironmentType Type { get; private set; }
    public ConnectionConfig ConnectionConfig { get; private set; }
    public bool IsDefault { get; private set; }
    public DateTime CreatedAt { get; private set; }

    public static Environment Create(EnvironmentId id, TenantId tenantId,
        string name, EnvironmentType type, ConnectionConfig config)

    public void SetAsDefault()
    public void UnsetAsDefault()
    public void UpdateConnection(ConnectionConfig config)
}

public enum EnvironmentType
{
    DockerSocket,
    DockerApi,      // Future
    DockerAgent     // Future
}

public sealed class ConnectionConfig : ValueObject
{
    public string SocketPath { get; }  // For DockerSocket
    // Future: ApiUrl, TlsCertificates, etc.

    public static ConnectionConfig DockerSocket(string path = "/var/run/docker.sock")
        => new(path);

    protected override IEnumerable<object> GetEqualityComponents() => [SocketPath];
}
```

#### Deployment (Aggregate Root)

```csharp
public class Deployment : AggregateRoot<DeploymentId>
{
    public DeploymentId Id { get; private set; }
    public EnvironmentId EnvironmentId { get; private set; }
    public string StackName { get; private set; }
    public string ProjectName { get; private set; }
    public DeploymentStatus Status { get; private set; }
    public string? ErrorMessage { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? CompletedAt { get; private set; }
    public UserId DeployedBy { get; private set; }

    private readonly List<DeployedService> _services;
    public IReadOnlyCollection<DeployedService> Services => _services.AsReadOnly();

    public static Deployment Start(DeploymentId id, EnvironmentId envId,
        string stackName, string projectName, UserId userId)

    public void MarkAsRunning(IEnumerable<DeployedService> services)
    public void MarkAsFailed(string errorMessage)
    public void MarkAsStopped()
    public void MarkAsRemoved()
}

public enum DeploymentStatus
{
    Pending,
    Running,
    Stopped,
    Failed,
    Removed
}
```

---

## Rollen & Berechtigungen

### Rollenübersicht

| Rolle | Scope | Beschreibung | Berechtigungen |
|-------|-------|--------------|----------------|
| SystemAdmin | Global | System-Administrator | Alles |
| OrganizationOwner | Organization | Org-Besitzer | Users, Environments, Stacks innerhalb der Org |
| Operator | Org/Environment | Stack-Operator | Deploy, Start, Stop, Remove Stacks |
| Viewer | Org/Environment | Nur Lesen | Lesen aller Ressourcen im Scope |

### Berechtigungsprüfung

```csharp
public class AuthorizationService
{
    public bool CanPerform(User user, Permission permission,
        ScopeType scopeType, string? scopeId)
    {
        foreach (var assignment in user.RoleAssignments)
        {
            // Global scope covers everything
            if (assignment.ScopeType == ScopeType.Global)
            {
                var role = GetRole(assignment.RoleId);
                if (role.Permissions.Any(p => p.Includes(permission)))
                    return true;
            }

            // Check matching scope
            if (assignment.ScopeType == scopeType && assignment.ScopeId == scopeId)
            {
                var role = GetRole(assignment.RoleId);
                if (role.Permissions.Any(p => p.Includes(permission)))
                    return true;
            }

            // Organization scope covers environments within
            if (assignment.ScopeType == ScopeType.Organization
                && scopeType == ScopeType.Environment)
            {
                var env = GetEnvironment(scopeId);
                if (env?.TenantId.Value.ToString() == assignment.ScopeId)
                {
                    var role = GetRole(assignment.RoleId);
                    if (role.Permissions.Any(p => p.Includes(permission)))
                        return true;
                }
            }
        }
        return false;
    }
}
```

---

## Domain Services

### TenantProvisioningService

```csharp
public class TenantProvisioningService
{
    private readonly ITenantRepository _tenantRepository;
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;

    public (Tenant, User) ProvisionTenant(
        string tenantName,
        string description,
        string adminUsername,
        string adminEmail,
        string adminPassword)
    {
        // 1. Create tenant
        var tenantId = _tenantRepository.NextIdentity();
        var tenant = Tenant.Provision(tenantId, tenantName, description);
        tenant.Activate();

        // 2. Create admin user
        var userId = _userRepository.NextIdentity();
        var email = new EmailAddress(adminEmail);
        var password = HashedPassword.Create(adminPassword, _passwordHasher);
        var user = User.Register(userId, tenantId, adminUsername, email, password);

        // 3. Assign roles
        user.AssignRole(new RoleAssignment(
            Role.SystemAdmin.Id,
            ScopeType.Global,
            null,
            DateTime.UtcNow));

        user.AssignRole(new RoleAssignment(
            Role.OrganizationOwner.Id,
            ScopeType.Organization,
            tenantId.Value.ToString(),
            DateTime.UtcNow));

        // 4. Persist
        _tenantRepository.Add(tenant);
        _userRepository.Add(user);

        return (tenant, user);
    }
}
```

### AuthenticationService

```csharp
public class AuthenticationService
{
    private readonly IUserRepository _userRepository;
    private readonly ITenantRepository _tenantRepository;
    private readonly IPasswordHasher _passwordHasher;

    public User? Authenticate(string username, string password)
    {
        var user = _userRepository.FindByUsername(username);
        if (user == null) return null;

        var tenant = _tenantRepository.Get(user.TenantId);
        if (tenant == null || !tenant.Active) return null;

        if (!user.Enablement.IsEnabled) return null;

        if (!user.Password.Verify(password, _passwordHasher)) return null;

        return user;
    }
}
```

---

## Repository Interfaces

```csharp
public interface ITenantRepository
{
    TenantId NextIdentity();
    void Add(Tenant tenant);
    Tenant? Get(TenantId id);
    Tenant? GetByName(string name);
    void Remove(Tenant tenant);
}

public interface IUserRepository
{
    UserId NextIdentity();
    void Add(User user);
    User? Get(UserId id);
    User? FindByUsername(string username);
    User? FindByEmail(EmailAddress email);
    IEnumerable<User> GetByTenant(TenantId tenantId);
    void Remove(User user);
}

public interface IRoleRepository
{
    Role? Get(RoleId id);
    IEnumerable<Role> GetAll();
}

public interface IEnvironmentRepository
{
    EnvironmentId NextIdentity();
    void Add(Environment environment);
    Environment? Get(EnvironmentId id);
    IEnumerable<Environment> GetByTenant(TenantId tenantId);
    Environment? GetDefault(TenantId tenantId);
    void Remove(Environment environment);
}

public interface IDeploymentRepository
{
    DeploymentId NextIdentity();
    void Add(Deployment deployment);
    Deployment? Get(DeploymentId id);
    IEnumerable<Deployment> GetByEnvironment(EnvironmentId envId);
    Deployment? GetByStackName(EnvironmentId envId, string stackName);
    void Remove(Deployment deployment);
}
```

---

## SQLite Schema

```sql
-- Tenants
CREATE TABLE Tenants (
    Id TEXT PRIMARY KEY,
    Name TEXT NOT NULL UNIQUE,
    Description TEXT,
    Active INTEGER NOT NULL DEFAULT 1,
    CreatedAt TEXT NOT NULL,
    UpdatedAt TEXT
);

-- Users
CREATE TABLE Users (
    Id TEXT PRIMARY KEY,
    TenantId TEXT NOT NULL REFERENCES Tenants(Id),
    Username TEXT NOT NULL,
    Email TEXT NOT NULL,
    PasswordHash TEXT NOT NULL,
    Enabled INTEGER NOT NULL DEFAULT 1,
    EnablementStartDate TEXT,
    EnablementEndDate TEXT,
    CreatedAt TEXT NOT NULL,
    UpdatedAt TEXT,
    UNIQUE(TenantId, Username),
    UNIQUE(Email)
);

-- Roles (seeded, read-only)
CREATE TABLE Roles (
    Id TEXT PRIMARY KEY,
    Name TEXT NOT NULL UNIQUE,
    Description TEXT,
    AllowedScopes INTEGER NOT NULL,  -- Flags: 1=Global, 2=Org, 4=Env
    Permissions TEXT NOT NULL        -- Comma-separated
);

-- UserRoles
CREATE TABLE UserRoles (
    Id TEXT PRIMARY KEY,
    UserId TEXT NOT NULL REFERENCES Users(Id) ON DELETE CASCADE,
    RoleId TEXT NOT NULL REFERENCES Roles(Id),
    ScopeType INTEGER NOT NULL,      -- 1=Global, 2=Org, 4=Env
    ScopeId TEXT,                    -- NULL for Global
    AssignedAt TEXT NOT NULL,
    UNIQUE(UserId, RoleId, ScopeType, ScopeId)
);

-- Environments
CREATE TABLE Environments (
    Id TEXT PRIMARY KEY,
    TenantId TEXT NOT NULL REFERENCES Tenants(Id),
    Name TEXT NOT NULL,
    Description TEXT,
    Type INTEGER NOT NULL,           -- 0=DockerSocket, 1=DockerApi, etc.
    ConnectionConfig TEXT NOT NULL,  -- JSON
    IsDefault INTEGER NOT NULL DEFAULT 0,
    CreatedAt TEXT NOT NULL,
    UpdatedAt TEXT,
    UNIQUE(TenantId, Name)
);

-- Deployments
CREATE TABLE Deployments (
    Id TEXT PRIMARY KEY,
    EnvironmentId TEXT NOT NULL REFERENCES Environments(Id),
    StackName TEXT NOT NULL,
    ProjectName TEXT NOT NULL,
    Status INTEGER NOT NULL,         -- 0=Pending, 1=Running, etc.
    ErrorMessage TEXT,
    DeployedById TEXT NOT NULL REFERENCES Users(Id),
    CreatedAt TEXT NOT NULL,
    CompletedAt TEXT,
    UNIQUE(EnvironmentId, ProjectName)
);

-- DeployedServices
CREATE TABLE DeployedServices (
    Id TEXT PRIMARY KEY,
    DeploymentId TEXT NOT NULL REFERENCES Deployments(Id) ON DELETE CASCADE,
    ServiceName TEXT NOT NULL,
    ContainerId TEXT,
    Status TEXT NOT NULL
);

-- StackSources
CREATE TABLE StackSources (
    Id TEXT PRIMARY KEY,
    TenantId TEXT NOT NULL REFERENCES Tenants(Id),
    Name TEXT NOT NULL,
    Type INTEGER NOT NULL,           -- 0=LocalDirectory, 1=GitRepository
    Configuration TEXT NOT NULL,     -- JSON
    LastSyncAt TEXT,
    CreatedAt TEXT NOT NULL,
    UNIQUE(TenantId, Name)
);

-- Indexes
CREATE INDEX IX_Users_TenantId ON Users(TenantId);
CREATE INDEX IX_Users_Email ON Users(Email);
CREATE INDEX IX_UserRoles_UserId ON UserRoles(UserId);
CREATE INDEX IX_Environments_TenantId ON Environments(TenantId);
CREATE INDEX IX_Deployments_EnvironmentId ON Deployments(EnvironmentId);
CREATE INDEX IX_StackSources_TenantId ON StackSources(TenantId);
```

---

## SpecFlow Test Scenarios

### Organization Provisioning

```gherkin
Feature: Organization Provisioning
    As a system installer
    I want to provision an organization with an admin user
    So that users can start managing their Docker stacks

Background:
    Given the system has no tenants configured

Scenario: Provision initial organization
    When I provision organization "ACME Corp" with description "Main organization"
    And I create admin user "admin" with email "admin@acme.com" and password "SecurePass123!"
    Then the organization "ACME Corp" should exist and be active
    And user "admin" should exist with email "admin@acme.com"
    And user "admin" should have role "SystemAdmin" with global scope
    And user "admin" should have role "OrganizationOwner" for organization "ACME Corp"

Scenario: Cannot provision organization with weak password
    When I try to provision organization "ACME Corp"
    And I try to create admin user "admin" with password "weak"
    Then the provisioning should fail with error "Password must be at least 8 characters"

Scenario: Cannot provision duplicate organization name
    Given organization "ACME Corp" exists
    When I try to provision organization "ACME Corp"
    Then the provisioning should fail with error "Organization name already exists"
```

### User Authentication

```gherkin
Feature: User Authentication
    As a user
    I want to authenticate with my credentials
    So that I can access the system

Background:
    Given organization "ACME Corp" exists and is active
    And user "admin" exists with password "SecurePass123!"

Scenario: Successful authentication
    When I authenticate with username "admin" and password "SecurePass123!"
    Then authentication should succeed
    And I should receive a valid JWT token

Scenario: Authentication fails with wrong password
    When I authenticate with username "admin" and password "WrongPassword"
    Then authentication should fail

Scenario: Authentication fails for disabled user
    Given user "admin" is disabled
    When I authenticate with username "admin" and password "SecurePass123!"
    Then authentication should fail

Scenario: Authentication fails for inactive organization
    Given organization "ACME Corp" is deactivated
    When I authenticate with username "admin" and password "SecurePass123!"
    Then authentication should fail
```

### Role-Based Access Control

```gherkin
Feature: Role-Based Access Control
    As an administrator
    I want to assign roles to users
    So that they have appropriate permissions

Background:
    Given organization "ACME Corp" exists
    And environment "Production" exists in "ACME Corp"
    And user "admin" is SystemAdmin
    And user "operator" exists in "ACME Corp"
    And user "viewer" exists in "ACME Corp"

Scenario: SystemAdmin can manage users
    When user "admin" tries to create user "newuser" in "ACME Corp"
    Then the operation should succeed

Scenario: Operator can deploy stacks
    Given user "operator" has role "Operator" for environment "Production"
    When user "operator" tries to deploy stack "wordpress" to "Production"
    Then the operation should succeed

Scenario: Operator cannot manage users
    Given user "operator" has role "Operator" for environment "Production"
    When user "operator" tries to create user "newuser" in "ACME Corp"
    Then the operation should fail with "Access denied"

Scenario: Viewer can only read
    Given user "viewer" has role "Viewer" for organization "ACME Corp"
    When user "viewer" tries to view deployments in "Production"
    Then the operation should succeed
    When user "viewer" tries to deploy stack "wordpress" to "Production"
    Then the operation should fail with "Access denied"

Scenario: Organization scope covers environments
    Given user "operator" has role "Operator" for organization "ACME Corp"
    And environment "Staging" exists in "ACME Corp"
    When user "operator" tries to deploy stack "wordpress" to "Staging"
    Then the operation should succeed
```

### Environment Management

```gherkin
Feature: Environment Management
    As an organization owner
    I want to manage Docker environments
    So that I can deploy stacks to different targets

Background:
    Given organization "ACME Corp" exists
    And user "admin" is OrganizationOwner of "ACME Corp"

Scenario: Create Docker Socket environment
    When user "admin" creates environment "Local Docker" of type "DockerSocket"
    Then environment "Local Docker" should exist
    And environment "Local Docker" should be the default

Scenario: Create multiple environments
    Given environment "Production" exists in "ACME Corp"
    When user "admin" creates environment "Staging" of type "DockerSocket"
    Then environment "Staging" should exist
    And environment "Production" should still be the default

Scenario: Change default environment
    Given environment "Production" exists and is default
    And environment "Staging" exists
    When user "admin" sets "Staging" as default
    Then environment "Staging" should be the default
    And environment "Production" should not be the default
```

---

## Migration Plan

### Phase 1: Domain Layer
1. Erstelle Base-Klassen (Entity, AggregateRoot, ValueObject)
2. Implementiere Identity Context (Tenant, User, Value Objects)
3. Implementiere Access Context (Role, Permission)
4. Schreibe SpecFlow Tests für Domain-Logik

### Phase 2: Infrastructure Layer
1. Erstelle DbContext mit EF Core
2. Implementiere Repository-Pattern für SQLite
3. Konfiguriere Entity Mappings
4. Schreibe Integration Tests

### Phase 3: Application Layer
1. Erstelle Application Services
2. Implementiere Command/Query Handler
3. Integriere mit bestehenden Endpoints
4. Aktualisiere Wizard-Flow

### Phase 4: Cleanup
1. Entferne JSON-basierte ConfigStore
2. Entferne alte Domain-Klassen
3. Aktualisiere Docker Volumes
4. Aktualisiere Dokumentation

---

## Zu löschende Dateien nach Migration

```
src/ReadyStackGo.Domain/Configuration/SystemConfig.cs     (ersetzt durch Tenant)
src/ReadyStackGo.Domain/Configuration/WizardState.cs      (ersetzt durch DB State)
src/ReadyStackGo.Domain/Configuration/DeploymentsConfig.cs (ersetzt durch Deployment Aggregate)
src/ReadyStackGo.Domain/Organizations/Organization.cs     (ersetzt durch Tenant)
src/ReadyStackGo.Infrastructure/Configuration/ConfigStore.cs (ersetzt durch Repositories)
```

---

## Offene Punkte

- [ ] JWT Token Refresh Strategie
- [ ] Audit Logging für Security Events
- [ ] Password Reset Flow (für v0.7+)
- [ ] User Self-Service (für v0.7+)
