# v0.4 Multi-Environment Specification

**Version:** 0.4.0
**Status:** Planning

---

## Overview

This specification defines the multi-environment feature for ReadyStackGo v0.4. Organizations can manage multiple isolated environments (e.g., Development, Testing, Production), each with independent configurations, Docker hosts, and deployed stacks.

**Key Principles:**
- **Minimal Variant:** Single Docker host per environment (multi-node support deferred to future releases)
- **Docker Host Uniqueness:** Each Docker host URL can only be used by one environment (prevents conflicts)
- **Environment Isolation:** Each environment has separate connection strings, Docker host, and deployed containers
- **Domain-Driven Design:** Organization and Environment are core domain aggregates with proper validation
- **User Experience:** Simple environment switching in UI with context-aware dashboard
- **Backward Compatibility:** v0.3 single-environment configurations automatically migrate to default environment

---

## Terminology

| Term | Definition |
|------|------------|
| **Organization** | A tenant entity defined in wizard Step 2 (organizationId, organizationName) - Domain Aggregate |
| **Environment** | An isolated deployment context within an organization (e.g., "dev", "test", "prod") - Domain Aggregate |
| **Active Environment** | The currently selected environment in the UI, stored in user session |
| **Default Environment** | The first environment created during wizard, typically "production" |
| **Docker Host** | A single Docker daemon endpoint (e.g., `tcp://192.168.1.10:2375` or `unix:///var/run/docker.sock`) - Must be unique across all environments |

---

## Use Cases

### UC-1: Create Multiple Environments
**Actor:** Admin User
**Preconditions:** Wizard completed (v0.3), logged in
**Flow:**
1. Admin navigates to Settings → Environments
2. Clicks "Add Environment"
3. Enters environment details (ID, name, Docker host URL)
4. Configures connection strings (Transport, Persistence, EventStore)
5. System validates and saves environment configuration
6. New environment appears in environment selector

### UC-2: Switch Between Environments
**Actor:** Admin User
**Preconditions:** Multiple environments exist
**Flow:**
1. Admin clicks environment selector dropdown in header
2. Selects different environment (e.g., "test" → "production")
3. UI updates active environment context
4. Dashboard, containers, stacks refresh to show selected environment's data
5. All subsequent operations affect only the active environment

### UC-3: Deploy Stack to Specific Environment
**Actor:** Admin User
**Preconditions:** Active environment selected
**Flow:**
1. Admin clicks "Deploy Stack" in dashboard
2. Selects manifest version
3. System deploys containers to active environment's Docker host
4. Containers use active environment's connection strings
5. Deployment status shows in active environment's dashboard

### UC-4: Migrate from v0.3 to v0.4
**Actor:** System
**Preconditions:** Existing v0.3 installation with rsgo.contexts.json
**Flow:**
1. User upgrades to v0.4
2. On first startup, system detects v0.3 configuration
3. System creates default environment ("production")
4. Migrates existing rsgo.contexts.json → rsgo.contexts.production.json
5. Updates rsgo.system.json with environments array
6. Logs migration success

---

## Data Model Changes

### System Configuration (`rsgo.system.json`)

**v0.3 Schema:**
```json
{
  "organizationId": "my-company",
  "organizationName": "My Company Ltd.",
  "wizardState": "Installed",
  "installedVersion": "v0.3.0",
  "createdAt": "2025-01-19T10:30:00Z",
  "updatedAt": "2025-01-19T10:35:00Z"
}
```

**v0.4 Schema (Extended):**
```json
{
  "organizationId": "my-company",
  "organizationName": "My Company Ltd.",
  "wizardState": "Installed",
  "installedVersion": "v0.4.0",
  "createdAt": "2025-01-19T10:30:00Z",
  "updatedAt": "2025-01-20T14:20:00Z",
  "environments": [
    {
      "id": "production",
      "name": "Production",
      "dockerHost": "tcp://192.168.1.10:2375",
      "isDefault": true,
      "createdAt": "2025-01-19T10:35:00Z"
    },
    {
      "id": "test",
      "name": "Test Environment",
      "dockerHost": "tcp://192.168.1.20:2375",
      "isDefault": false,
      "createdAt": "2025-01-20T14:20:00Z"
    }
  ]
}
```

**Schema Definition:**
```typescript
interface SystemConfig {
  organizationId: string;
  organizationName: string;
  wizardState: WizardState;
  installedVersion: string;
  createdAt: string; // ISO 8601
  updatedAt: string; // ISO 8601
  environments: Environment[]; // NEW in v0.4
}

interface Environment {
  id: string;           // Lowercase alphanumeric + hyphens (e.g., "production", "dev-env")
  name: string;         // Display name (e.g., "Production", "Development")
  dockerHost: string;   // Docker daemon URL (e.g., "tcp://host:2375", "unix:///var/run/docker.sock")
  isDefault: boolean;   // True for the default environment
  createdAt: string;    // ISO 8601
}
```

**Validation Rules:**
- At least one environment must exist after wizard completion
- Exactly one environment must have `isDefault: true`
- Environment IDs must be unique within organization
- Environment ID format: `/^[a-z0-9-]+$/` (lowercase, numbers, hyphens only)
- **Docker Host URLs must be unique across all environments** (no two environments can share the same Docker host)

### Environment-Specific Contexts Configuration

**File Naming Convention:**
- **v0.3:** `rsgo.contexts.json` (single file)
- **v0.4:** `rsgo.contexts.{environmentId}.json` (per environment)

**Example Files:**
```
/app/config/
  rsgo.system.json
  rsgo.security.json
  rsgo.tls.json
  rsgo.contexts.production.json  ← Production environment
  rsgo.contexts.test.json         ← Test environment
  rsgo.contexts.dev.json          ← Development environment
```

**File Schema (`rsgo.contexts.{env}.json`):**
```json
{
  "environmentId": "production",
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;Database=rsgo;Username=admin;Password=***",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  },
  "advanced": null
}
```

**C# Model:**
```csharp
public class ContextsConfig
{
    public string EnvironmentId { get; set; } = string.Empty; // NEW in v0.4
    public ConnectionMode ConnectionMode { get; set; } = ConnectionMode.Simple;
    public SimpleConnectionConfig? Simple { get; set; }
    public AdvancedConnectionConfig? Advanced { get; set; } // Future use
}
```

---

## Wizard Changes

### Current v0.3 Wizard (4 Steps)
1. Create Admin Account
2. Set Organization
3. Configure Connections (Simple mode)
4. Complete Setup

### Proposed v0.4 Wizard (5 Steps)

**Option A: Add Environment Step**
1. Create Admin Account
2. Set Organization
3. **Create Default Environment** ← NEW STEP
   - Environment ID (e.g., "production")
   - Environment Name (e.g., "Production")
   - Docker Host URL (e.g., "tcp://192.168.1.10:2375")
4. Configure Connections (now scoped to default environment)
5. Complete Setup

**Option B: Combine Organization + Environment (RECOMMENDED)**
1. Create Admin Account
2. **Set Organization & Default Environment** ← COMBINED STEP
   - Organization ID
   - Organization Name
   - Default Environment ID (default: "production")
   - Default Environment Name (default: "Production")
   - Docker Host URL
3. Configure Connections (scoped to default environment)
4. Complete Setup

**Recommendation:** Option B keeps wizard at 4 steps, avoids overwhelming users, and provides sensible defaults.

### Wizard State Enum Update

```csharp
// v0.3
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationSet,
    ConnectionsSet,
    Installed
}

// v0.4 (if using Option A)
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationSet,
    EnvironmentCreated,    // NEW
    ConnectionsSet,
    Installed
}

// v0.4 (if using Option B - RECOMMENDED)
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationAndEnvironmentSet,  // RENAMED from OrganizationSet
    ConnectionsSet,
    Installed
}
```

---

## API Changes

### New Endpoints

**Get All Environments**
```http
GET /api/environments
Authorization: Bearer {token}

Response 200 OK:
{
  "environments": [
    {
      "id": "production",
      "name": "Production",
      "dockerHost": "tcp://192.168.1.10:2375",
      "isDefault": true,
      "createdAt": "2025-01-19T10:35:00Z"
    },
    {
      "id": "test",
      "name": "Test Environment",
      "dockerHost": "tcp://192.168.1.20:2375",
      "isDefault": false,
      "createdAt": "2025-01-20T14:20:00Z"
    }
  ]
}
```

**Create Environment**
```http
POST /api/environments
Authorization: Bearer {token}
Content-Type: application/json

{
  "id": "staging",
  "name": "Staging Environment",
  "dockerHost": "tcp://192.168.1.30:2375"
}

Response 201 Created:
{
  "id": "staging",
  "name": "Staging Environment",
  "dockerHost": "tcp://192.168.1.30:2375",
  "isDefault": false,
  "createdAt": "2025-01-20T15:00:00Z"
}
```

**Update Environment**
```http
PUT /api/environments/{id}
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "Staging (Updated)",
  "dockerHost": "tcp://192.168.1.35:2375"
}

Response 200 OK
```

**Delete Environment**
```http
DELETE /api/environments/{id}
Authorization: Bearer {token}

Response 204 No Content
```
**Constraints:** Cannot delete default environment or environment with active deployments.

**Get Environment Connections**
```http
GET /api/environments/{id}/connections
Authorization: Bearer {token}

Response 200 OK:
{
  "environmentId": "production",
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;...",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  }
}
```

**Update Environment Connections**
```http
PUT /api/environments/{id}/connections
Authorization: Bearer {token}
Content-Type: application/json

{
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;...",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  }
}

Response 200 OK
```

### Modified Endpoints

**Container Endpoints (Environment-Scoped)**
```http
# v0.3
GET /api/containers

# v0.4
GET /api/containers?environment={environmentId}
```

**Deployment Endpoints (Environment-Scoped)**
```http
# v0.3
POST /api/deployments

# v0.4
POST /api/deployments
{
  "environmentId": "production",  ← NEW REQUIRED FIELD
  "manifestPath": "/app/manifests/v1.0.0.json"
}
```

---

## Domain Model

### Architecture

Organization and Environment are promoted to first-class domain aggregates in v0.4, moving away from simple configuration DTOs.

**New Domain Structure:**

```
src/ReadyStackGo.Domain/
├── Auth/
│   ├── User.cs
│   └── UserRole.cs
├── Organization/              ← NEW in v0.4
│   ├── Organization.cs        ← Aggregate Root
│   ├── OrganizationId.cs      ← Value Object
│   └── Exceptions/
│       └── OrganizationException.cs
├── Environment/               ← NEW in v0.4
│   ├── Environment.cs         ← Aggregate Root
│   ├── EnvironmentId.cs       ← Value Object
│   └── Exceptions/
│       └── EnvironmentException.cs
└── Wizard/
    ├── WizardState.cs
    └── ConnectionMode.cs
```

### Domain Aggregate: Organization

```csharp
namespace ReadyStackGo.Domain.Organization;

public class Organization
{
    public OrganizationId Id { get; private set; }
    public string Name { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime UpdatedAt { get; private set; }

    private Organization() { } // For EF Core

    public static Organization Create(string id, string name)
    {
        if (string.IsNullOrWhiteSpace(id))
            throw new OrganizationException("Organization ID cannot be empty");

        if (!OrganizationId.IsValid(id))
            throw new OrganizationException($"Invalid organization ID format: {id}");

        if (string.IsNullOrWhiteSpace(name))
            throw new OrganizationException("Organization name cannot be empty");

        return new Organization
        {
            Id = new OrganizationId(id),
            Name = name,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
    }

    public void UpdateName(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName))
            throw new OrganizationException("Organization name cannot be empty");

        Name = newName;
        UpdatedAt = DateTime.UtcNow;
    }
}

// Value Object
public record OrganizationId
{
    public string Value { get; }

    public OrganizationId(string value)
    {
        if (!IsValid(value))
            throw new OrganizationException($"Invalid organization ID: {value}");

        Value = value;
    }

    public static bool IsValid(string id) =>
        !string.IsNullOrWhiteSpace(id) &&
        Regex.IsMatch(id, @"^[a-z0-9-]+$");

    public override string ToString() => Value;
}
```

### Domain Aggregate: Environment

```csharp
namespace ReadyStackGo.Domain.Environment;

public class Environment
{
    public EnvironmentId Id { get; private set; }
    public string Name { get; private set; }
    public OrganizationId OrganizationId { get; private set; }
    public string DockerHost { get; private set; }
    public bool IsDefault { get; private set; }
    public DateTime CreatedAt { get; private set; }

    private Environment() { }

    public static Environment Create(
        string id,
        string name,
        OrganizationId organizationId,
        string dockerHost,
        bool isDefault = false)
    {
        if (!EnvironmentId.IsValid(id))
            throw new EnvironmentException($"Invalid environment ID: {id}");

        if (string.IsNullOrWhiteSpace(name))
            throw new EnvironmentException("Environment name cannot be empty");

        if (string.IsNullOrWhiteSpace(dockerHost))
            throw new EnvironmentException("Docker host URL cannot be empty");

        if (!IsValidDockerHostUrl(dockerHost))
            throw new EnvironmentException($"Invalid Docker host URL: {dockerHost}");

        return new Environment
        {
            Id = new EnvironmentId(id),
            Name = name,
            OrganizationId = organizationId,
            DockerHost = dockerHost,
            IsDefault = isDefault,
            CreatedAt = DateTime.UtcNow
        };
    }

    public void UpdateDockerHost(string newDockerHost)
    {
        if (!IsValidDockerHostUrl(newDockerHost))
            throw new EnvironmentException($"Invalid Docker host URL: {newDockerHost}");

        DockerHost = newDockerHost;
    }

    public void MarkAsDefault()
    {
        IsDefault = true;
    }

    public void UnmarkAsDefault()
    {
        IsDefault = false;
    }

    private static bool IsValidDockerHostUrl(string url)
    {
        return url.StartsWith("unix://") ||
               url.StartsWith("tcp://") ||
               url.StartsWith("http://") ||
               url.StartsWith("https://");
    }
}

// Value Object
public record EnvironmentId
{
    public string Value { get; }

    public EnvironmentId(string value)
    {
        if (!IsValid(value))
            throw new EnvironmentException($"Invalid environment ID: {value}");

        Value = value;
    }

    public static bool IsValid(string id) =>
        !string.IsNullOrWhiteSpace(id) &&
        Regex.IsMatch(id, @"^[a-z0-9-]+$");

    public override string ToString() => Value;
}
```

### Domain Validation Rules

**Organization:**
- ID must be lowercase alphanumeric with hyphens only (`^[a-z0-9-]+$`)
- Name cannot be empty
- IDs are immutable once created

**Environment:**
- ID must be lowercase alphanumeric with hyphens only (`^[a-z0-9-]+$`)
- Name cannot be empty
- Docker Host URL must start with `unix://`, `tcp://`, `http://`, or `https://`
- **Docker Host URL must be unique across all environments (enforced at Application layer)**
- Exactly one environment per organization must be marked as default
- Environment IDs are immutable once created

### Why Domain Aggregates?

**Benefits:**
1. **Encapsulation:** Business rules are enforced in the domain, not scattered across services
2. **Type Safety:** `OrganizationId` and `EnvironmentId` prevent string-based errors
3. **Testability:** Domain logic can be tested independently without infrastructure
4. **Maintainability:** Clear separation between domain logic and persistence
5. **Scalability:** Easy to extend with new business rules (e.g., environment templates, cloning)

---

## Backend Services

### New: `IEnvironmentService`

```csharp
public interface IEnvironmentService
{
    Task<List<Environment>> GetAllEnvironmentsAsync();
    Task<Environment?> GetEnvironmentAsync(string environmentId);
    Task<Environment> CreateEnvironmentAsync(CreateEnvironmentRequest request);
    Task<Environment> UpdateEnvironmentAsync(string environmentId, UpdateEnvironmentRequest request);
    Task DeleteEnvironmentAsync(string environmentId);
    Task<Environment> GetDefaultEnvironmentAsync();
    Task SetDefaultEnvironmentAsync(string environmentId);
}

public class EnvironmentService : IEnvironmentService
{
    private readonly IConfigStore _configStore;
    private readonly ILogger<EnvironmentService> _logger;

    public async Task<List<Environment>> GetAllEnvironmentsAsync()
    {
        var systemConfig = await _configStore.GetSystemConfigAsync();
        return systemConfig.Environments;
    }

    public async Task<Environment> CreateEnvironmentAsync(CreateEnvironmentRequest request)
    {
        var systemConfig = await _configStore.GetSystemConfigAsync();

        // Validate unique environment ID
        if (systemConfig.Environments.Any(e => e.Id == request.Id))
        {
            throw new InvalidOperationException($"Environment with ID '{request.Id}' already exists.");
        }

        // Validate unique Docker host URL
        if (systemConfig.Environments.Any(e => e.DockerHost == request.DockerHost))
        {
            throw new InvalidOperationException(
                $"Docker host '{request.DockerHost}' is already used by another environment. " +
                "Each environment must have a unique Docker host.");
        }

        var newEnvironment = new Environment
        {
            Id = request.Id,
            Name = request.Name,
            DockerHost = request.DockerHost,
            IsDefault = systemConfig.Environments.Count == 0, // First environment is default
            CreatedAt = DateTime.UtcNow
        };

        systemConfig.Environments.Add(newEnvironment);
        await _configStore.SaveSystemConfigAsync(systemConfig);

        // Create empty contexts config for new environment
        var contextsConfig = new ContextsConfig
        {
            EnvironmentId = newEnvironment.Id,
            ConnectionMode = ConnectionMode.Simple,
            Simple = new SimpleConnectionConfig()
        };
        await _configStore.SaveContextsConfigAsync(newEnvironment.Id, contextsConfig);

        return newEnvironment;
    }

    // ... other methods
}
```

### Modified: `IConfigStore`

```csharp
public interface IConfigStore
{
    // Existing methods
    Task<SystemConfig> GetSystemConfigAsync();
    Task SaveSystemConfigAsync(SystemConfig config);
    Task<SecurityConfig> GetSecurityConfigAsync();
    Task SaveSecurityConfigAsync(SecurityConfig config);
    Task<TlsConfig> GetTlsConfigAsync();
    Task SaveTlsConfigAsync(TlsConfig config);

    // v0.3 - Single contexts file
    Task<ContextsConfig> GetContextsConfigAsync();
    Task SaveContextsConfigAsync(ContextsConfig config);

    // v0.4 - Per-environment contexts files (NEW)
    Task<ContextsConfig> GetContextsConfigAsync(string environmentId);
    Task SaveContextsConfigAsync(string environmentId, ContextsConfig config);
}
```

**Implementation:**
```csharp
public async Task<ContextsConfig> GetContextsConfigAsync(string environmentId)
{
    var fileName = $"rsgo.contexts.{environmentId}.json";
    var filePath = Path.Combine(_configDirectory, fileName);

    if (!File.Exists(filePath))
    {
        _logger.LogWarning("Contexts config not found for environment: {EnvironmentId}", environmentId);
        return new ContextsConfig { EnvironmentId = environmentId };
    }

    var json = await File.ReadAllTextAsync(filePath);
    var config = JsonSerializer.Deserialize<ContextsConfig>(json, _jsonOptions);
    return config ?? new ContextsConfig { EnvironmentId = environmentId };
}

public async Task SaveContextsConfigAsync(string environmentId, ContextsConfig config)
{
    var fileName = $"rsgo.contexts.{environmentId}.json";
    var filePath = Path.Combine(_configDirectory, fileName);

    config.EnvironmentId = environmentId; // Ensure consistency

    var json = JsonSerializer.Serialize(config, _jsonOptions);
    await File.WriteAllTextAsync(filePath, json);

    _logger.LogInformation("Saved contexts config for environment: {EnvironmentId}", environmentId);
}
```

### Modified: `IDockerService`

```csharp
// v0.3
public interface IDockerService
{
    Task<List<ContainerInfo>> ListContainersAsync();
    Task<ContainerInfo> GetContainerAsync(string containerId);
    Task StartContainerAsync(string containerId);
    Task StopContainerAsync(string containerId);
}

// v0.4 - Environment-aware
public interface IDockerService
{
    Task<List<ContainerInfo>> ListContainersAsync(string environmentId);
    Task<ContainerInfo> GetContainerAsync(string environmentId, string containerId);
    Task StartContainerAsync(string environmentId, string containerId);
    Task StopContainerAsync(string environmentId, string containerId);
    Task<bool> TestConnectionAsync(string dockerHostUrl); // NEW - Test Docker host connectivity
}
```

**Implementation:**
```csharp
public class DockerService : IDockerService
{
    private readonly IEnvironmentService _environmentService;
    private readonly ILogger<DockerService> _logger;

    public async Task<List<ContainerInfo>> ListContainersAsync(string environmentId)
    {
        var environment = await _environmentService.GetEnvironmentAsync(environmentId);
        if (environment == null)
        {
            throw new InvalidOperationException($"Environment '{environmentId}' not found.");
        }

        var client = CreateDockerClient(environment.DockerHost);

        var containers = await client.Containers.ListContainersAsync(new ContainersListParameters
        {
            All = true
        });

        return containers.Select(c => new ContainerInfo
        {
            Id = c.ID,
            Name = c.Names.FirstOrDefault()?.TrimStart('/') ?? "unknown",
            Image = c.Image,
            State = c.State,
            Status = c.Status
        }).ToList();
    }

    private DockerClient CreateDockerClient(string dockerHostUrl)
    {
        var config = new DockerClientConfiguration(new Uri(dockerHostUrl));
        return config.CreateClient();
    }

    public async Task<bool> TestConnectionAsync(string dockerHostUrl)
    {
        try
        {
            var client = CreateDockerClient(dockerHostUrl);
            await client.System.PingAsync();
            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

---

## Frontend Changes

### New Component: `EnvironmentSelector`

**Location:** `src/components/EnvironmentSelector.tsx`

```tsx
import { useState, useEffect } from 'react';
import { useEnvironment } from '../hooks/useEnvironment';

export default function EnvironmentSelector() {
  const { environments, activeEnvironment, setActiveEnvironment } = useEnvironment();
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 dark:bg-gray-800 dark:text-gray-200 dark:border-gray-600"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
        </svg>
        <span>{activeEnvironment?.name || 'Select Environment'}</span>
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute right-0 z-10 mt-2 w-64 bg-white border border-gray-200 rounded-lg shadow-lg dark:bg-gray-800 dark:border-gray-700">
          <div className="p-2">
            {environments.map((env) => (
              <button
                key={env.id}
                onClick={() => {
                  setActiveEnvironment(env.id);
                  setIsOpen(false);
                }}
                className={`w-full px-4 py-2 text-left text-sm rounded-md transition-colors ${
                  activeEnvironment?.id === env.id
                    ? 'bg-brand-100 text-brand-700 dark:bg-brand-900 dark:text-brand-300'
                    : 'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
                }`}
              >
                <div className="flex items-center justify-between">
                  <span className="font-medium">{env.name}</span>
                  {env.isDefault && (
                    <span className="text-xs text-gray-500 dark:text-gray-400">Default</span>
                  )}
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                  {env.dockerHost}
                </div>
              </button>
            ))}
          </div>
          <div className="border-t border-gray-200 dark:border-gray-700 p-2">
            <a
              href="/settings/environments"
              className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md dark:text-gray-300 dark:hover:bg-gray-700"
            >
              Manage Environments
            </a>
          </div>
        </div>
      )}
    </div>
  );
}
```

### New Hook: `useEnvironment`

**Location:** `src/hooks/useEnvironment.ts`

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { getEnvironments } from '../services/api';

interface Environment {
  id: string;
  name: string;
  dockerHost: string;
  isDefault: boolean;
  createdAt: string;
}

interface EnvironmentContextType {
  environments: Environment[];
  activeEnvironment: Environment | null;
  setActiveEnvironment: (environmentId: string) => void;
  refreshEnvironments: () => Promise<void>;
}

const EnvironmentContext = createContext<EnvironmentContextType | undefined>(undefined);

export function EnvironmentProvider({ children }: { children: ReactNode }) {
  const [environments, setEnvironments] = useState<Environment[]>([]);
  const [activeEnvironmentId, setActiveEnvironmentId] = useState<string | null>(
    localStorage.getItem('activeEnvironmentId')
  );

  const activeEnvironment = environments.find(e => e.id === activeEnvironmentId) || null;

  const refreshEnvironments = async () => {
    try {
      const data = await getEnvironments();
      setEnvironments(data.environments);

      // Set default environment if none active
      if (!activeEnvironmentId && data.environments.length > 0) {
        const defaultEnv = data.environments.find(e => e.isDefault) || data.environments[0];
        setActiveEnvironmentId(defaultEnv.id);
        localStorage.setItem('activeEnvironmentId', defaultEnv.id);
      }
    } catch (error) {
      console.error('Failed to load environments:', error);
    }
  };

  const setActiveEnvironment = (environmentId: string) => {
    setActiveEnvironmentId(environmentId);
    localStorage.setItem('activeEnvironmentId', environmentId);
  };

  useEffect(() => {
    refreshEnvironments();
  }, []);

  return (
    <EnvironmentContext.Provider
      value={{ environments, activeEnvironment, setActiveEnvironment, refreshEnvironments }}
    >
      {children}
    </EnvironmentContext.Provider>
  );
}

export function useEnvironment() {
  const context = useContext(EnvironmentContext);
  if (!context) {
    throw new Error('useEnvironment must be used within EnvironmentProvider');
  }
  return context;
}
```

### Modified: `DashboardLayout`

```tsx
import EnvironmentSelector from '../components/EnvironmentSelector';

export default function DashboardLayout({ children }: { children: ReactNode }) {
  return (
    <div>
      <header className="flex items-center justify-between p-4 border-b">
        <h1>ReadyStackGo Admin</h1>
        <div className="flex items-center gap-4">
          <EnvironmentSelector /> {/* NEW */}
          <UserMenu />
        </div>
      </header>
      <main>{children}</main>
    </div>
  );
}
```

### Modified: `ContainersPage`

```tsx
import { useEnvironment } from '../hooks/useEnvironment';

export default function ContainersPage() {
  const { activeEnvironment } = useEnvironment();
  const [containers, setContainers] = useState([]);

  useEffect(() => {
    if (activeEnvironment) {
      loadContainers(activeEnvironment.id);
    }
  }, [activeEnvironment]);

  const loadContainers = async (environmentId: string) => {
    const data = await getContainers(environmentId);
    setContainers(data);
  };

  if (!activeEnvironment) {
    return <div>No environment selected</div>;
  }

  return (
    <div>
      <h2>Containers - {activeEnvironment.name}</h2>
      {/* Container list */}
    </div>
  );
}
```

---

## Migration Strategy (v0.3 → v0.4)

### Automatic Migration on Startup

**Detection Logic:**
```csharp
public async Task<bool> IsMigrationNeededAsync()
{
    var systemConfig = await _configStore.GetSystemConfigAsync();

    // Check if v0.3 format (no environments array)
    return systemConfig.Environments == null || systemConfig.Environments.Count == 0;
}

public async Task MigrateFromV03Async()
{
    _logger.LogInformation("Starting migration from v0.3 to v0.4");

    // 1. Load existing v0.3 system config
    var systemConfig = await _configStore.GetSystemConfigAsync();

    // 2. Create default environment
    var defaultEnvironment = new Environment
    {
        Id = "production",
        Name = "Production",
        DockerHost = "unix:///var/run/docker.sock", // Default to local Docker
        IsDefault = true,
        CreatedAt = DateTime.UtcNow
    };

    systemConfig.Environments = new List<Environment> { defaultEnvironment };
    systemConfig.InstalledVersion = "v0.4.0";
    systemConfig.UpdatedAt = DateTime.UtcNow;

    await _configStore.SaveSystemConfigAsync(systemConfig);

    // 3. Migrate rsgo.contexts.json → rsgo.contexts.production.json
    var oldContextsPath = Path.Combine(_configDirectory, "rsgo.contexts.json");
    var newContextsPath = Path.Combine(_configDirectory, "rsgo.contexts.production.json");

    if (File.Exists(oldContextsPath))
    {
        var contextsJson = await File.ReadAllTextAsync(oldContextsPath);
        var contextsConfig = JsonSerializer.Deserialize<ContextsConfig>(contextsJson);

        if (contextsConfig != null)
        {
            contextsConfig.EnvironmentId = "production";
            await _configStore.SaveContextsConfigAsync("production", contextsConfig);

            // Backup old file
            File.Move(oldContextsPath, oldContextsPath + ".v0.3.backup");
        }
    }

    _logger.LogInformation("Migration to v0.4 completed successfully");
}
```

**Startup Hook in `Program.cs`:**
```csharp
// After TLS bootstrap, before HTTP pipeline
await MigrateConfigurationAsync(app);

private static async Task MigrateConfigurationAsync(WebApplication app)
{
    using var scope = app.Services.CreateScope();
    var migrationService = scope.ServiceProvider.GetRequiredService<IMigrationService>();
    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

    try
    {
        if (await migrationService.IsMigrationNeededAsync())
        {
            logger.LogInformation("Detected v0.3 configuration. Starting migration to v0.4...");
            await migrationService.MigrateFromV03Async();
            logger.LogInformation("Configuration migration completed successfully.");
        }
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Configuration migration failed. Manual intervention may be required.");
    }
}
```

---

## Testing Strategy

### Unit Tests
- `EnvironmentService` CRUD operations
- `ConfigStore` environment-specific file operations
- Migration logic from v0.3 to v0.4
- Environment validation (unique IDs, default environment constraints)

### Integration Tests
- `GET /api/environments` returns all environments
- `POST /api/environments` creates new environment
- `DELETE /api/environments/{id}` fails for default environment
- `GET /api/containers?environment=test` returns only test environment containers
- Migration from v0.3 config format to v0.4

### E2E Tests (Playwright)
- Environment selector dropdown interaction
- Switch between environments updates dashboard
- Create new environment via Settings page
- Deploy stack to specific environment
- Migration flow: upgrade from v0.3, verify default environment created

---

## Out of Scope for v0.4

The following features are explicitly **NOT included** in v0.4 and deferred to future releases:

### Multi-Node Support (Deferred to v0.5+)
- Multiple Docker hosts per environment
- Load balancing across nodes
- Node health monitoring
- Distributed container orchestration

### Advanced Features (Future)
- Environment templates
- Environment cloning
- Cross-environment promotion workflows
- Environment-specific RBAC
- Audit logs per environment

---

## Open Questions

1. **Docker Host Security:** Should we support TLS-secured Docker hosts in v0.4, or only plain TCP/Unix sockets?
   - **Recommendation:** Support basic auth (TCP/Unix) in v0.4, TLS in v0.5

2. **Environment Deletion:** What happens to deployed containers when environment is deleted?
   - **Recommendation:** Prevent deletion if containers exist; require manual cleanup first

3. **Environment Limits:** Should there be a max number of environments per organization?
   - **Recommendation:** No hard limit in v0.4; add if performance issues arise

4. **Wizard Defaults:** Should wizard auto-detect local Docker daemon, or require user input?
   - **Recommendation:** Auto-detect `unix:///var/run/docker.sock` if available, otherwise prompt

---

## Success Criteria

v0.4 is considered complete when:

- ✅ Users can create multiple environments via UI
- ✅ Users can switch between environments using dropdown selector
- ✅ Dashboard/containers/stacks are filtered by active environment
- ✅ Each environment has independent connection strings configuration
- ✅ Each environment connects to a different Docker host
- ✅ Stack deployments are scoped to active environment
- ✅ v0.3 installations automatically migrate to v0.4 with default environment
- ✅ All unit/integration/E2E tests pass
- ✅ Documentation updated (README, CHANGELOG, release notes)

---

## Timeline Estimate

| Phase | Duration | Tasks |
|-------|----------|-------|
| **Design** | 1 week | Finalize API contracts, UI mockups, database schema |
| **Backend** | 2 weeks | Implement EnvironmentService, ConfigStore changes, migration logic |
| **Frontend** | 1 week | Build EnvironmentSelector, Settings page, hook integration |
| **Testing** | 1 week | Unit, integration, E2E tests |
| **Documentation** | 3 days | Update all docs, write migration guide |
| **QA & Bug Fixes** | 1 week | User acceptance testing, polish |

**Total:** ~6 weeks (1.5 months)

---

## References

- [v0.3.0 Release Notes](../Release-Notes/v0.3.0.md)
- [CHANGELOG.md](../../CHANGELOG.md)
- [Docker Engine API](https://docs.docker.com/engine/api/)
- [Clean Architecture Principles](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
