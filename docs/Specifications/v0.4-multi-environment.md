# v0.4 Multi-Environment Specification

**Version:** 0.4.0
**Status:** Planning

---

## Overview

This specification defines the multi-environment feature for ReadyStackGo v0.4. Organizations can manage multiple isolated environments (e.g., Development, Testing, Production), each with independent configurations, Docker hosts, and deployed stacks.

**Key Principles:**
- **Minimal Variant:** Single Docker host per environment (multi-node support deferred to future releases)
- **Docker Host Uniqueness:** Each Docker host URL can only be used by one environment (prevents conflicts)
- **Environment Isolation:** Each environment has separate connection strings, Docker host, and deployed containers
- **Domain-Driven Design:** Organization and Environment are core domain aggregates with proper validation
- **User Experience:** Simple environment switching in UI with context-aware dashboard
- **Backward Compatibility:** v0.3 single-environment configurations automatically migrate to default environment

---

## Terminology

| Term | Definition |
|------|------------|
| **Organization** | A tenant entity defined in wizard Step 2 (organizationId, organizationName) - **Aggregate Root** |
| **Environment** | An isolated deployment context within an organization (e.g., "dev", "test", "prod") - **Entity** within Organization aggregate |
| **Active Environment** | The currently selected environment in the UI, stored in user session |
| **Default Environment** | The first environment created during wizard, typically "production" |
| **Docker Host** | A single Docker daemon endpoint (e.g., `tcp://192.168.1.10:2375` or `unix:///var/run/docker.sock`) - Must be unique across all environments |

---

## Use Cases

### UC-1: Create Multiple Environments
**Actor:** Admin User
**Preconditions:** Wizard completed (v0.3), logged in
**Flow:**
1. Admin navigates to Settings → Environments
2. Clicks "Add Environment"
3. Enters environment details (ID, name, Docker host URL)
4. Configures connection strings (Transport, Persistence, EventStore)
5. System validates and saves environment configuration
6. New environment appears in environment selector

### UC-2: Switch Between Environments
**Actor:** Admin User
**Preconditions:** Multiple environments exist
**Flow:**
1. Admin clicks environment selector dropdown in header
2. Selects different environment (e.g., "test" → "production")
3. UI updates active environment context
4. Dashboard, containers, stacks refresh to show selected environment's data
5. All subsequent operations affect only the active environment

### UC-3: Deploy Stack to Specific Environment
**Actor:** Admin User
**Preconditions:** Active environment selected
**Flow:**
1. Admin clicks "Deploy Stack" in dashboard
2. Selects manifest version
3. System deploys containers to active environment's Docker host
4. Containers use active environment's connection strings
5. Deployment status shows in active environment's dashboard

### UC-4: Migrate from v0.3 to v0.4
**Actor:** System
**Preconditions:** Existing v0.3 installation with rsgo.contexts.json
**Flow:**
1. User upgrades to v0.4
2. On first startup, system detects v0.3 configuration
3. System creates default environment ("production")
4. Migrates existing rsgo.contexts.json → rsgo.contexts.production.json
5. Updates rsgo.system.json with environments array
6. Logs migration success

---

## Data Model Changes

### System Configuration (`rsgo.system.json`)

**v0.3 Schema:**
```json
{
  "organizationId": "my-company",
  "organizationName": "My Company Ltd.",
  "wizardState": "Installed",
  "installedVersion": "v0.3.0",
  "createdAt": "2025-01-19T10:30:00Z",
  "updatedAt": "2025-01-19T10:35:00Z"
}
```

**v0.4 Schema (Extended):**
```json
{
  "organizationId": "my-company",
  "organizationName": "My Company Ltd.",
  "wizardState": "Installed",
  "installedVersion": "v0.4.0",
  "createdAt": "2025-01-19T10:30:00Z",
  "updatedAt": "2025-01-20T14:20:00Z",
  "environments": [
    {
      "id": "production",
      "name": "Production",
      "dockerHost": "tcp://192.168.1.10:2375",
      "isDefault": true,
      "createdAt": "2025-01-19T10:35:00Z"
    },
    {
      "id": "test",
      "name": "Test Environment",
      "dockerHost": "tcp://192.168.1.20:2375",
      "isDefault": false,
      "createdAt": "2025-01-20T14:20:00Z"
    }
  ]
}
```

**Schema Definition:**
```typescript
interface SystemConfig {
  organizationId: string;
  organizationName: string;
  wizardState: WizardState;
  installedVersion: string;
  createdAt: string; // ISO 8601
  updatedAt: string; // ISO 8601
  environments: Environment[]; // NEW in v0.4
}

interface Environment {
  id: string;           // Lowercase alphanumeric + hyphens (e.g., "production", "dev-env")
  name: string;         // Display name (e.g., "Production", "Development")
  dockerHost: string;   // Docker daemon URL (e.g., "tcp://host:2375", "unix:///var/run/docker.sock")
  isDefault: boolean;   // True for the default environment
  createdAt: string;    // ISO 8601
}
```

**Validation Rules:**
- At least one environment must exist after wizard completion
- Exactly one environment must have `isDefault: true`
- Environment IDs must be unique within organization
- Environment ID format: `/^[a-z0-9-]+$/` (lowercase, numbers, hyphens only)
- **Docker Host URLs must be unique across all environments** (no two environments can share the same Docker host)

### Environment-Specific Contexts Configuration

**File Naming Convention:**
- **v0.3:** `rsgo.contexts.json` (single file)
- **v0.4:** `rsgo.contexts.{environmentId}.json` (per environment)

**Example Files:**
```
/app/config/
  rsgo.system.json
  rsgo.security.json
  rsgo.tls.json
  rsgo.contexts.production.json  ← Production environment
  rsgo.contexts.test.json         ← Test environment
  rsgo.contexts.dev.json          ← Development environment
```

**File Schema (`rsgo.contexts.{env}.json`):**
```json
{
  "environmentId": "production",
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;Database=rsgo;Username=admin;Password=***",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  },
  "advanced": null
}
```

**C# Model:**
```csharp
public class ContextsConfig
{
    public string EnvironmentId { get; set; } = string.Empty; // NEW in v0.4
    public ConnectionMode ConnectionMode { get; set; } = ConnectionMode.Simple;
    public SimpleConnectionConfig? Simple { get; set; }
    public AdvancedConnectionConfig? Advanced { get; set; } // Future use
}
```

---

## Wizard Changes

### Current v0.3 Wizard (4 Steps)
1. Create Admin Account
2. Set Organization
3. Configure Connections (Simple mode)
4. Complete Setup

### Proposed v0.4 Wizard (5 Steps)

**Option A: Add Environment Step**
1. Create Admin Account
2. Set Organization
3. **Create Default Environment** ← NEW STEP
   - Environment ID (e.g., "production")
   - Environment Name (e.g., "Production")
   - Docker Host URL (e.g., "tcp://192.168.1.10:2375")
4. Configure Connections (now scoped to default environment)
5. Complete Setup

**Option B: Combine Organization + Environment (RECOMMENDED)**
1. Create Admin Account
2. **Set Organization & Default Environment** ← COMBINED STEP
   - Organization ID
   - Organization Name
   - Default Environment ID (default: "production")
   - Default Environment Name (default: "Production")
   - Docker Host URL
3. Configure Connections (scoped to default environment)
4. Complete Setup

**Recommendation:** Option B keeps wizard at 4 steps, avoids overwhelming users, and provides sensible defaults.

### Wizard State Enum Update

```csharp
// v0.3
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationSet,
    ConnectionsSet,
    Installed
}

// v0.4 (if using Option A)
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationSet,
    EnvironmentCreated,    // NEW
    ConnectionsSet,
    Installed
}

// v0.4 (if using Option B - RECOMMENDED)
public enum WizardState
{
    NotStarted,
    AdminCreated,
    OrganizationAndEnvironmentSet,  // RENAMED from OrganizationSet
    ConnectionsSet,
    Installed
}
```

---

## API Changes

### New Endpoints

**Get All Environments**
```http
GET /api/environments
Authorization: Bearer {token}

Response 200 OK:
{
  "environments": [
    {
      "id": "production",
      "name": "Production",
      "dockerHost": "tcp://192.168.1.10:2375",
      "isDefault": true,
      "createdAt": "2025-01-19T10:35:00Z"
    },
    {
      "id": "test",
      "name": "Test Environment",
      "dockerHost": "tcp://192.168.1.20:2375",
      "isDefault": false,
      "createdAt": "2025-01-20T14:20:00Z"
    }
  ]
}
```

**Create Environment**
```http
POST /api/environments
Authorization: Bearer {token}
Content-Type: application/json

{
  "id": "staging",
  "name": "Staging Environment",
  "dockerHost": "tcp://192.168.1.30:2375"
}

Response 201 Created:
{
  "id": "staging",
  "name": "Staging Environment",
  "dockerHost": "tcp://192.168.1.30:2375",
  "isDefault": false,
  "createdAt": "2025-01-20T15:00:00Z"
}
```

**Update Environment**
```http
PUT /api/environments/{id}
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "Staging (Updated)",
  "dockerHost": "tcp://192.168.1.35:2375"
}

Response 200 OK
```

**Delete Environment**
```http
DELETE /api/environments/{id}
Authorization: Bearer {token}

Response 204 No Content
```
**Constraints:** Cannot delete default environment or environment with active deployments.

**Get Environment Connections**
```http
GET /api/environments/{id}/connections
Authorization: Bearer {token}

Response 200 OK:
{
  "environmentId": "production",
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;...",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  }
}
```

**Update Environment Connections**
```http
PUT /api/environments/{id}/connections
Authorization: Bearer {token}
Content-Type: application/json

{
  "connectionMode": "Simple",
  "simple": {
    "transport": "amqp://rabbitmq-prod:5672",
    "persistence": "Host=db-prod;Port=5432;...",
    "eventStore": "esdb://eventstore-prod:2113?tls=false"
  }
}

Response 200 OK
```

### Modified Endpoints

**Container Endpoints (Environment-Scoped)**
```http
# v0.3
GET /api/containers

# v0.4
GET /api/containers?environment={environmentId}
```

**Deployment Endpoints (Environment-Scoped)**
```http
# v0.3
POST /api/deployments

# v0.4
POST /api/deployments
{
  "environmentId": "production",  ← NEW REQUIRED FIELD
  "manifestPath": "/app/manifests/v1.0.0.json"
}
```

---

## Domain Model

### Architecture

**Aggregate Design:** Organization is the **Aggregate Root**, and Environment is an **Entity** within the Organization aggregate. This design ensures all invariants (uniqueness constraints, default environment rules) can be enforced within a single transactional boundary.

**New Domain Structure:**

```
src/ReadyStackGo.Domain/
├── Auth/
│   ├── User.cs
│   └── UserRole.cs
├── Organization/              ← NEW in v0.4
│   ├── Organization.cs        ← Aggregate Root
│   ├── Environment.cs         ← Entity (part of Organization aggregate)
│   ├── OrganizationId.cs      ← Value Object
│   ├── EnvironmentId.cs       ← Value Object
│   └── Exceptions/
│       └── OrganizationException.cs
└── Wizard/
    ├── WizardState.cs
    └── ConnectionMode.cs
```

**Key Design Decision:**
- Environment is **NOT** a separate aggregate root
- Environment entities are owned by and managed through the Organization aggregate
- This ensures transactional consistency for invariants like "exactly one default environment" and "unique Docker hosts within organization"

### Domain Aggregate: Organization (Aggregate Root)

```csharp
namespace ReadyStackGo.Domain.Organization;

public class Organization
{
    public OrganizationId Id { get; private set; }
    public string Name { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime UpdatedAt { get; private set; }

    private readonly List<Environment> _environments = new();
    public IReadOnlyCollection<Environment> Environments => _environments.AsReadOnly();

    private Organization() { }

    // Factory Method: Create Organization WITH default Environment
    public static Organization Create(
        string id,
        string name,
        string defaultEnvironmentId,
        string defaultEnvironmentName,
        string dockerHost)
    {
        if (string.IsNullOrWhiteSpace(id))
            throw new OrganizationException("Organization ID cannot be empty");

        if (!OrganizationId.IsValid(id))
            throw new OrganizationException($"Invalid organization ID format: {id}");

        if (string.IsNullOrWhiteSpace(name))
            throw new OrganizationException("Organization name cannot be empty");

        var organization = new Organization
        {
            Id = new OrganizationId(id),
            Name = name,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        // Create default environment (first environment is always default)
        var defaultEnvironment = Environment.Create(
            defaultEnvironmentId,
            defaultEnvironmentName,
            dockerHost,
            isDefault: true);

        organization._environments.Add(defaultEnvironment);

        return organization;
    }

    // Business Logic: Add new Environment
    public Environment AddEnvironment(string id, string name, string dockerHost)
    {
        // Invariant: Environment ID must be unique
        if (_environments.Any(e => e.Id.Value == id))
            throw new OrganizationException($"Environment with ID '{id}' already exists");

        // Invariant: Docker Host must be unique
        if (_environments.Any(e => e.DockerHost == dockerHost))
            throw new OrganizationException($"Docker host '{dockerHost}' is already used by another environment");

        var environment = Environment.Create(id, name, dockerHost, isDefault: false);
        _environments.Add(environment);
        UpdatedAt = DateTime.UtcNow;

        return environment;
    }

    // Business Logic: Remove Environment
    public void RemoveEnvironment(string environmentId)
    {
        var environment = _environments.FirstOrDefault(e => e.Id.Value == environmentId)
            ?? throw new OrganizationException($"Environment '{environmentId}' not found");

        // Invariant: Cannot delete default environment
        if (environment.IsDefault)
            throw new OrganizationException(
                "Cannot delete default environment. Set another environment as default first.");

        // Invariant: Must have at least one environment
        if (_environments.Count <= 1)
            throw new OrganizationException(
                "Cannot delete last environment. Organization must have at least one environment.");

        _environments.Remove(environment);
        UpdatedAt = DateTime.UtcNow;
    }

    // Business Logic: Change default Environment
    public void SetDefaultEnvironment(string environmentId)
    {
        var newDefault = _environments.FirstOrDefault(e => e.Id.Value == environmentId)
            ?? throw new OrganizationException($"Environment '{environmentId}' not found");

        // Remove default from all other environments
        foreach (var env in _environments.Where(e => e.IsDefault))
        {
            env.UnmarkAsDefault();
        }

        // Set new default
        newDefault.MarkAsDefault();
        UpdatedAt = DateTime.UtcNow;
    }

    // Business Logic: Update Docker Host
    public void UpdateEnvironmentDockerHost(string environmentId, string newDockerHost)
    {
        var environment = _environments.FirstOrDefault(e => e.Id.Value == environmentId)
            ?? throw new OrganizationException($"Environment '{environmentId}' not found");

        // Invariant: Docker Host must be unique (except for this environment)
        if (_environments.Any(e => e.Id.Value != environmentId && e.DockerHost == newDockerHost))
            throw new OrganizationException(
                $"Docker host '{newDockerHost}' is already used by another environment");

        environment.UpdateDockerHost(newDockerHost);
        UpdatedAt = DateTime.UtcNow;
    }

    public void UpdateName(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName))
            throw new OrganizationException("Organization name cannot be empty");

        Name = newName;
        UpdatedAt = DateTime.UtcNow;
    }

    public Environment GetDefaultEnvironment()
    {
        return _environments.First(e => e.IsDefault);
    }

    public Environment? GetEnvironment(string environmentId)
    {
        return _environments.FirstOrDefault(e => e.Id.Value == environmentId);
    }
}

// Value Object
public record OrganizationId
{
    public string Value { get; }

    public OrganizationId(string value)
    {
        if (!IsValid(value))
            throw new OrganizationException($"Invalid organization ID: {value}");

        Value = value;
    }

    public static bool IsValid(string id) =>
        !string.IsNullOrWhiteSpace(id) &&
        Regex.IsMatch(id, @"^[a-z0-9-]+$");

    public override string ToString() => Value;
}
```

### Domain Entity: Environment

**Important:** Environment is an **Entity**, not an Aggregate Root. It can only be created and modified through the Organization aggregate.

```csharp
namespace ReadyStackGo.Domain.Organization;

public class Environment
{
    public EnvironmentId Id { get; private set; }
    public string Name { get; private set; }
    public string DockerHost { get; private set; }
    public bool IsDefault { get; private set; }
    public DateTime CreatedAt { get; private set; }

    private Environment() { }

    // Factory Method (internal - only Organization can create Environments)
    internal static Environment Create(
        string id,
        string name,
        string dockerHost,
        bool isDefault)
    {
        if (!EnvironmentId.IsValid(id))
            throw new OrganizationException($"Invalid environment ID: {id}");

        if (string.IsNullOrWhiteSpace(name))
            throw new OrganizationException("Environment name cannot be empty");

        if (string.IsNullOrWhiteSpace(dockerHost))
            throw new OrganizationException("Docker host URL cannot be empty");

        if (!IsValidDockerHostUrl(dockerHost))
            throw new OrganizationException($"Invalid Docker host URL: {dockerHost}");

        return new Environment
        {
            Id = new EnvironmentId(id),
            Name = name,
            DockerHost = dockerHost,
            IsDefault = isDefault,
            CreatedAt = DateTime.UtcNow
        };
    }

    // Internal methods (only Organization aggregate can call these)
    internal void UpdateDockerHost(string newDockerHost)
    {
        if (!IsValidDockerHostUrl(newDockerHost))
            throw new OrganizationException($"Invalid Docker host URL: {newDockerHost}");

        DockerHost = newDockerHost;
    }

    internal void MarkAsDefault()
    {
        IsDefault = true;
    }

    internal void UnmarkAsDefault()
    {
        IsDefault = false;
    }

    internal void UpdateName(string newName)
    {
        if (string.IsNullOrWhiteSpace(newName))
            throw new OrganizationException("Environment name cannot be empty");

        Name = newName;
    }

    private static bool IsValidDockerHostUrl(string url)
    {
        return url.StartsWith("unix://") ||
               url.StartsWith("tcp://") ||
               url.StartsWith("http://") ||
               url.StartsWith("https://");
    }
}

// Value Object
public record EnvironmentId
{
    public string Value { get; }

    public EnvironmentId(string value)
    {
        if (!IsValid(value))
            throw new OrganizationException($"Invalid environment ID: {value}");

        Value = value;
    }

    public static bool IsValid(string id) =>
        !string.IsNullOrWhiteSpace(id) &&
        Regex.IsMatch(id, @"^[a-z0-9-]+$");

    public override string ToString() => Value;
}
```

### Domain Validation Rules

**Organization:**
- ID must be lowercase alphanumeric with hyphens only (`^[a-z0-9-]+$`)
- Name cannot be empty
- IDs are immutable once created

**Environment:**
- ID must be lowercase alphanumeric with hyphens only (`^[a-z0-9-]+$`)
- Name cannot be empty
- Docker Host URL must start with `unix://`, `tcp://`, `http://`, or `https://`
- **Docker Host URL must be unique across all environments (enforced in Organization aggregate)**
- Exactly one environment per organization must be marked as default (enforced in Organization aggregate)
- Cannot delete default environment unless another environment is set as default first
- Cannot delete last environment (organization must always have at least one)
- Environment IDs are immutable once created

### Why Domain Aggregates?

**Benefits:**
1. **Encapsulation:** Business rules are enforced in the domain, not scattered across services
2. **Type Safety:** `OrganizationId` and `EnvironmentId` prevent string-based errors
3. **Testability:** Domain logic can be tested independently without infrastructure
4. **Maintainability:** Clear separation between domain logic and persistence
5. **Scalability:** Easy to extend with new business rules (e.g., environment templates, cloning)
6. **Transactional Consistency:** Single aggregate = single transaction boundary = ACID guarantees

---

## Persistence Strategy

### v0.4: JSON-Based File Storage

**Decision:** Continue using JSON files for v0.4 to maintain simplicity and consistency with v0.3.

**Rationale:**
- ✅ No external database setup required
- ✅ Simple deployment (mount `/app/config` volume)
- ✅ Easy backup and restore (copy config directory)
- ✅ Human-readable configuration
- ✅ Consistent with v0.3 architecture
- ✅ Adequate for single-user, single-organization use case

**File Structure:**

```
/app/config/
  rsgo.system.json                  ← Organization + Environments
  rsgo.security.json                ← Admin credentials
  rsgo.contexts.production.json     ← Production environment connections
  rsgo.contexts.test.json           ← Test environment connections
  rsgo.tls.json                     ← TLS configuration
```

**System Configuration Schema (`rsgo.system.json`):**

```json
{
  "organization": {
    "id": "acme-corp",
    "name": "Acme Corporation",
    "createdAt": "2025-01-19T10:00:00Z",
    "updatedAt": "2025-01-20T14:30:00Z",
    "environments": [
      {
        "id": "production",
        "name": "Production",
        "dockerHost": "tcp://prod-docker.acme.local:2375",
        "isDefault": true,
        "createdAt": "2025-01-19T10:00:00Z"
      },
      {
        "id": "test",
        "name": "Test Environment",
        "dockerHost": "tcp://test-docker.acme.local:2375",
        "isDefault": false,
        "createdAt": "2025-01-20T14:30:00Z"
      }
    ]
  },
  "wizardState": "Installed",
  "installedVersion": "v0.4.0"
}
```

**Repository Implementation:**

```csharp
public class OrganizationRepository : IOrganizationRepository
{
    private readonly string _configPath = "/app/config/rsgo.system.json";
    private readonly SemaphoreSlim _lock = new(1, 1); // Prevent concurrent writes
    private readonly JsonSerializerOptions _jsonOptions;

    public async Task<Organization> GetAsync()
    {
        await _lock.WaitAsync();
        try
        {
            if (!File.Exists(_configPath))
                throw new InvalidOperationException("Organization not found. Complete the wizard first.");

            var json = await File.ReadAllTextAsync(_configPath);
            var dto = JsonSerializer.Deserialize<SystemConfigDto>(json, _jsonOptions);

            return MapToDomain(dto.Organization);
        }
        finally
        {
            _lock.Release();
        }
    }

    public async Task SaveAsync(Organization organization)
    {
        await _lock.WaitAsync();
        try
        {
            var json = File.Exists(_configPath)
                ? await File.ReadAllTextAsync(_configPath)
                : "{}";

            var dto = JsonSerializer.Deserialize<SystemConfigDto>(json, _jsonOptions)
                ?? new SystemConfigDto();

            dto.Organization = MapToDto(organization);
            dto.UpdatedAt = DateTime.UtcNow;

            var updatedJson = JsonSerializer.Serialize(dto, _jsonOptions);
            await File.WriteAllTextAsync(_configPath, updatedJson);
        }
        finally
        {
            _lock.Release();
        }
    }

    private Organization MapToDomain(OrganizationDto dto)
    {
        // Create organization with default environment
        var defaultEnv = dto.Environments.First(e => e.IsDefault);
        var org = Organization.Create(
            dto.Id,
            dto.Name,
            defaultEnv.Id,
            defaultEnv.Name,
            defaultEnv.DockerHost);

        // Add remaining environments
        foreach (var envDto in dto.Environments.Where(e => !e.IsDefault))
        {
            org.AddEnvironment(envDto.Id, envDto.Name, envDto.DockerHost);
        }

        return org;
    }
}
```

**Concurrency Handling:**
- `SemaphoreSlim` prevents concurrent file writes
- Last-write-wins strategy (acceptable for single-user scenario)
- Future: Optimistic concurrency with version numbers

**Limitations:**
- ⚠️ No ACID transactions (file write is atomic, but not with other config files)
- ⚠️ Not suitable for multi-user scenarios (no locking across instances)
- ⚠️ Performance degrades with many environments (>100)

### Future: SQLite Migration (v0.5 or v0.6)

**When to migrate:**
- Multi-user support is added
- More than ~20 environments per organization
- Need for advanced querying or reporting

**Benefits of SQLite:**
- ✅ ACID transactions
- ✅ Better concurrency handling
- ✅ EF Core support (migrations, LINQ queries)
- ✅ Still file-based (no external database)
- ✅ Easy backup (single `.db` file)

**Migration Plan:**
1. Keep `IOrganizationRepository` interface unchanged
2. Create `SqliteOrganizationRepository` implementation
3. Provide migration tool: `rsgo.system.json` → `readystackgo.db`
4. Update documentation

**Schema (EF Core):**

```csharp
public class OrganizationConfiguration : IEntityTypeConfiguration<Organization>
{
    public void Configure(EntityTypeBuilder<Organization> builder)
    {
        builder.ToTable("Organizations");
        builder.HasKey(o => o.Id);

        builder.Property(o => o.Id)
            .HasConversion(
                id => id.Value,
                value => new OrganizationId(value));

        builder.Property(o => o.Name).IsRequired();
        builder.Property(o => o.CreatedAt).IsRequired();
        builder.Property(o => o.UpdatedAt).IsRequired();

        // Environments as owned entities
        builder.OwnsMany(o => o.Environments, env =>
        {
            env.ToTable("Environments");
            env.WithOwner().HasForeignKey("OrganizationId");

            env.Property(e => e.Id)
                .HasConversion(
                    id => id.Value,
                    value => new EnvironmentId(value));

            env.Property(e => e.Name).IsRequired();
            env.Property(e => e.DockerHost).IsRequired();
            env.Property(e => e.IsDefault).IsRequired();
            env.Property(e => e.CreatedAt).IsRequired();

            env.HasIndex(e => new { e.OrganizationId, e.DockerHost }).IsUnique();
        });
    }
}
```

**Recommendation:** Defer SQLite migration to v0.5 or v0.6 when multi-user support is added.

---

## Backend Services

### New: `IEnvironmentService`

```csharp
public interface IEnvironmentService
{
    Task<List<Environment>> GetAllEnvironmentsAsync();
    Task<Environment?> GetEnvironmentAsync(string environmentId);
    Task<Environment> CreateEnvironmentAsync(CreateEnvironmentRequest request);
    Task<Environment> UpdateEnvironmentAsync(string environmentId, UpdateEnvironmentRequest request);
    Task DeleteEnvironmentAsync(string environmentId);
    Task<Environment> GetDefaultEnvironmentAsync();
    Task SetDefaultEnvironmentAsync(string environmentId);
}

public class EnvironmentService : IEnvironmentService
{
    private readonly IConfigStore _configStore;
    private readonly ILogger<EnvironmentService> _logger;

    public async Task<List<Environment>> GetAllEnvironmentsAsync()
    {
        var systemConfig = await _configStore.GetSystemConfigAsync();
        return systemConfig.Environments;
    }

    public async Task<Environment> CreateEnvironmentAsync(CreateEnvironmentRequest request)
    {
        var systemConfig = await _configStore.GetSystemConfigAsync();

        // Validate unique environment ID
        if (systemConfig.Environments.Any(e => e.Id == request.Id))
        {
            throw new InvalidOperationException($"Environment with ID '{request.Id}' already exists.");
        }

        // Validate unique Docker host URL
        if (systemConfig.Environments.Any(e => e.DockerHost == request.DockerHost))
        {
            throw new InvalidOperationException(
                $"Docker host '{request.DockerHost}' is already used by another environment. " +
                "Each environment must have a unique Docker host.");
        }

        var newEnvironment = new Environment
        {
            Id = request.Id,
            Name = request.Name,
            DockerHost = request.DockerHost,
            IsDefault = systemConfig.Environments.Count == 0, // First environment is default
            CreatedAt = DateTime.UtcNow
        };

        systemConfig.Environments.Add(newEnvironment);
        await _configStore.SaveSystemConfigAsync(systemConfig);

        // Create empty contexts config for new environment
        var contextsConfig = new ContextsConfig
        {
            EnvironmentId = newEnvironment.Id,
            ConnectionMode = ConnectionMode.Simple,
            Simple = new SimpleConnectionConfig()
        };
        await _configStore.SaveContextsConfigAsync(newEnvironment.Id, contextsConfig);

        return newEnvironment;
    }

    // ... other methods
}
```

### Modified: `IConfigStore`

```csharp
public interface IConfigStore
{
    // Existing methods
    Task<SystemConfig> GetSystemConfigAsync();
    Task SaveSystemConfigAsync(SystemConfig config);
    Task<SecurityConfig> GetSecurityConfigAsync();
    Task SaveSecurityConfigAsync(SecurityConfig config);
    Task<TlsConfig> GetTlsConfigAsync();
    Task SaveTlsConfigAsync(TlsConfig config);

    // v0.3 - Single contexts file
    Task<ContextsConfig> GetContextsConfigAsync();
    Task SaveContextsConfigAsync(ContextsConfig config);

    // v0.4 - Per-environment contexts files (NEW)
    Task<ContextsConfig> GetContextsConfigAsync(string environmentId);
    Task SaveContextsConfigAsync(string environmentId, ContextsConfig config);
}
```

**Implementation:**
```csharp
public async Task<ContextsConfig> GetContextsConfigAsync(string environmentId)
{
    var fileName = $"rsgo.contexts.{environmentId}.json";
    var filePath = Path.Combine(_configDirectory, fileName);

    if (!File.Exists(filePath))
    {
        _logger.LogWarning("Contexts config not found for environment: {EnvironmentId}", environmentId);
        return new ContextsConfig { EnvironmentId = environmentId };
    }

    var json = await File.ReadAllTextAsync(filePath);
    var config = JsonSerializer.Deserialize<ContextsConfig>(json, _jsonOptions);
    return config ?? new ContextsConfig { EnvironmentId = environmentId };
}

public async Task SaveContextsConfigAsync(string environmentId, ContextsConfig config)
{
    var fileName = $"rsgo.contexts.{environmentId}.json";
    var filePath = Path.Combine(_configDirectory, fileName);

    config.EnvironmentId = environmentId; // Ensure consistency

    var json = JsonSerializer.Serialize(config, _jsonOptions);
    await File.WriteAllTextAsync(filePath, json);

    _logger.LogInformation("Saved contexts config for environment: {EnvironmentId}", environmentId);
}
```

### Modified: `IDockerService`

```csharp
// v0.3
public interface IDockerService
{
    Task<List<ContainerInfo>> ListContainersAsync();
    Task<ContainerInfo> GetContainerAsync(string containerId);
    Task StartContainerAsync(string containerId);
    Task StopContainerAsync(string containerId);
}

// v0.4 - Environment-aware
public interface IDockerService
{
    Task<List<ContainerInfo>> ListContainersAsync(string environmentId);
    Task<ContainerInfo> GetContainerAsync(string environmentId, string containerId);
    Task StartContainerAsync(string environmentId, string containerId);
    Task StopContainerAsync(string environmentId, string containerId);
    Task<bool> TestConnectionAsync(string dockerHostUrl); // NEW - Test Docker host connectivity
}
```

**Implementation:**
```csharp
public class DockerService : IDockerService
{
    private readonly IEnvironmentService _environmentService;
    private readonly ILogger<DockerService> _logger;

    public async Task<List<ContainerInfo>> ListContainersAsync(string environmentId)
    {
        var environment = await _environmentService.GetEnvironmentAsync(environmentId);
        if (environment == null)
        {
            throw new InvalidOperationException($"Environment '{environmentId}' not found.");
        }

        var client = CreateDockerClient(environment.DockerHost);

        var containers = await client.Containers.ListContainersAsync(new ContainersListParameters
        {
            All = true
        });

        return containers.Select(c => new ContainerInfo
        {
            Id = c.ID,
            Name = c.Names.FirstOrDefault()?.TrimStart('/') ?? "unknown",
            Image = c.Image,
            State = c.State,
            Status = c.Status
        }).ToList();
    }

    private DockerClient CreateDockerClient(string dockerHostUrl)
    {
        var config = new DockerClientConfiguration(new Uri(dockerHostUrl));
        return config.CreateClient();
    }

    public async Task<bool> TestConnectionAsync(string dockerHostUrl)
    {
        try
        {
            var client = CreateDockerClient(dockerHostUrl);
            await client.System.PingAsync();
            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

---

## Frontend Changes

### New Component: `EnvironmentSelector`

**Location:** `src/components/EnvironmentSelector.tsx`

```tsx
import { useState, useEffect } from 'react';
import { useEnvironment } from '../hooks/useEnvironment';

export default function EnvironmentSelector() {
  const { environments, activeEnvironment, setActiveEnvironment } = useEnvironment();
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 dark:bg-gray-800 dark:text-gray-200 dark:border-gray-600"
      >
        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
        </svg>
        <span>{activeEnvironment?.name || 'Select Environment'}</span>
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {isOpen && (
        <div className="absolute right-0 z-10 mt-2 w-64 bg-white border border-gray-200 rounded-lg shadow-lg dark:bg-gray-800 dark:border-gray-700">
          <div className="p-2">
            {environments.map((env) => (
              <button
                key={env.id}
                onClick={() => {
                  setActiveEnvironment(env.id);
                  setIsOpen(false);
                }}
                className={`w-full px-4 py-2 text-left text-sm rounded-md transition-colors ${
                  activeEnvironment?.id === env.id
                    ? 'bg-brand-100 text-brand-700 dark:bg-brand-900 dark:text-brand-300'
                    : 'text-gray-700 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700'
                }`}
              >
                <div className="flex items-center justify-between">
                  <span className="font-medium">{env.name}</span>
                  {env.isDefault && (
                    <span className="text-xs text-gray-500 dark:text-gray-400">Default</span>
                  )}
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                  {env.dockerHost}
                </div>
              </button>
            ))}
          </div>
          <div className="border-t border-gray-200 dark:border-gray-700 p-2">
            <a
              href="/settings/environments"
              className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 rounded-md dark:text-gray-300 dark:hover:bg-gray-700"
            >
              Manage Environments
            </a>
          </div>
        </div>
      )}
    </div>
  );
}
```

### New Hook: `useEnvironment`

**Location:** `src/hooks/useEnvironment.ts`

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { getEnvironments } from '../services/api';

interface Environment {
  id: string;
  name: string;
  dockerHost: string;
  isDefault: boolean;
  createdAt: string;
}

interface EnvironmentContextType {
  environments: Environment[];
  activeEnvironment: Environment | null;
  setActiveEnvironment: (environmentId: string) => void;
  refreshEnvironments: () => Promise<void>;
}

const EnvironmentContext = createContext<EnvironmentContextType | undefined>(undefined);

export function EnvironmentProvider({ children }: { children: ReactNode }) {
  const [environments, setEnvironments] = useState<Environment[]>([]);
  const [activeEnvironmentId, setActiveEnvironmentId] = useState<string | null>(
    localStorage.getItem('activeEnvironmentId')
  );

  const activeEnvironment = environments.find(e => e.id === activeEnvironmentId) || null;

  const refreshEnvironments = async () => {
    try {
      const data = await getEnvironments();
      setEnvironments(data.environments);

      // Set default environment if none active
      if (!activeEnvironmentId && data.environments.length > 0) {
        const defaultEnv = data.environments.find(e => e.isDefault) || data.environments[0];
        setActiveEnvironmentId(defaultEnv.id);
        localStorage.setItem('activeEnvironmentId', defaultEnv.id);
      }
    } catch (error) {
      console.error('Failed to load environments:', error);
    }
  };

  const setActiveEnvironment = (environmentId: string) => {
    setActiveEnvironmentId(environmentId);
    localStorage.setItem('activeEnvironmentId', environmentId);
  };

  useEffect(() => {
    refreshEnvironments();
  }, []);

  return (
    <EnvironmentContext.Provider
      value={{ environments, activeEnvironment, setActiveEnvironment, refreshEnvironments }}
    >
      {children}
    </EnvironmentContext.Provider>
  );
}

export function useEnvironment() {
  const context = useContext(EnvironmentContext);
  if (!context) {
    throw new Error('useEnvironment must be used within EnvironmentProvider');
  }
  return context;
}
```

### Modified: `DashboardLayout`

```tsx
import EnvironmentSelector from '../components/EnvironmentSelector';

export default function DashboardLayout({ children }: { children: ReactNode }) {
  return (
    <div>
      <header className="flex items-center justify-between p-4 border-b">
        <h1>ReadyStackGo Admin</h1>
        <div className="flex items-center gap-4">
          <EnvironmentSelector /> {/* NEW */}
          <UserMenu />
        </div>
      </header>
      <main>{children}</main>
    </div>
  );
}
```

### Modified: `ContainersPage`

```tsx
import { useEnvironment } from '../hooks/useEnvironment';

export default function ContainersPage() {
  const { activeEnvironment } = useEnvironment();
  const [containers, setContainers] = useState([]);

  useEffect(() => {
    if (activeEnvironment) {
      loadContainers(activeEnvironment.id);
    }
  }, [activeEnvironment]);

  const loadContainers = async (environmentId: string) => {
    const data = await getContainers(environmentId);
    setContainers(data);
  };

  if (!activeEnvironment) {
    return <div>No environment selected</div>;
  }

  return (
    <div>
      <h2>Containers - {activeEnvironment.name}</h2>
      {/* Container list */}
    </div>
  );
}
```

---

## Migration Strategy (v0.3 → v0.4)

### Automatic Migration on Startup

**Detection Logic:**
```csharp
public async Task<bool> IsMigrationNeededAsync()
{
    var systemConfig = await _configStore.GetSystemConfigAsync();

    // Check if v0.3 format (no environments array)
    return systemConfig.Environments == null || systemConfig.Environments.Count == 0;
}

public async Task MigrateFromV03Async()
{
    _logger.LogInformation("Starting migration from v0.3 to v0.4");

    // 1. Load existing v0.3 system config
    var systemConfig = await _configStore.GetSystemConfigAsync();

    // 2. Create default environment
    var defaultEnvironment = new Environment
    {
        Id = "production",
        Name = "Production",
        DockerHost = "unix:///var/run/docker.sock", // Default to local Docker
        IsDefault = true,
        CreatedAt = DateTime.UtcNow
    };

    systemConfig.Environments = new List<Environment> { defaultEnvironment };
    systemConfig.InstalledVersion = "v0.4.0";
    systemConfig.UpdatedAt = DateTime.UtcNow;

    await _configStore.SaveSystemConfigAsync(systemConfig);

    // 3. Migrate rsgo.contexts.json → rsgo.contexts.production.json
    var oldContextsPath = Path.Combine(_configDirectory, "rsgo.contexts.json");
    var newContextsPath = Path.Combine(_configDirectory, "rsgo.contexts.production.json");

    if (File.Exists(oldContextsPath))
    {
        var contextsJson = await File.ReadAllTextAsync(oldContextsPath);
        var contextsConfig = JsonSerializer.Deserialize<ContextsConfig>(contextsJson);

        if (contextsConfig != null)
        {
            contextsConfig.EnvironmentId = "production";
            await _configStore.SaveContextsConfigAsync("production", contextsConfig);

            // Backup old file
            File.Move(oldContextsPath, oldContextsPath + ".v0.3.backup");
        }
    }

    _logger.LogInformation("Migration to v0.4 completed successfully");
}
```

**Startup Hook in `Program.cs`:**
```csharp
// After TLS bootstrap, before HTTP pipeline
await MigrateConfigurationAsync(app);

private static async Task MigrateConfigurationAsync(WebApplication app)
{
    using var scope = app.Services.CreateScope();
    var migrationService = scope.ServiceProvider.GetRequiredService<IMigrationService>();
    var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

    try
    {
        if (await migrationService.IsMigrationNeededAsync())
        {
            logger.LogInformation("Detected v0.3 configuration. Starting migration to v0.4...");
            await migrationService.MigrateFromV03Async();
            logger.LogInformation("Configuration migration completed successfully.");
        }
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Configuration migration failed. Manual intervention may be required.");
    }
}
```

---

## Testing Strategy

### Unit Tests
- `EnvironmentService` CRUD operations
- `ConfigStore` environment-specific file operations
- Migration logic from v0.3 to v0.4
- Environment validation (unique IDs, default environment constraints)

### Integration Tests
- `GET /api/environments` returns all environments
- `POST /api/environments` creates new environment
- `DELETE /api/environments/{id}` fails for default environment
- `GET /api/containers?environment=test` returns only test environment containers
- Migration from v0.3 config format to v0.4

### E2E Tests (Playwright)
- Environment selector dropdown interaction
- Switch between environments updates dashboard
- Create new environment via Settings page
- Deploy stack to specific environment
- Migration flow: upgrade from v0.3, verify default environment created

---

## Out of Scope for v0.4

The following features are explicitly **NOT included** in v0.4 and deferred to future releases:

### Multi-Node Support (Deferred to v0.5+)
- Multiple Docker hosts per environment
- Load balancing across nodes
- Node health monitoring
- Distributed container orchestration

### Advanced Features (Future)
- Environment templates
- Environment cloning
- Cross-environment promotion workflows
- Environment-specific RBAC
- Audit logs per environment

---

## Open Questions

1. **Docker Host Security:** Should we support TLS-secured Docker hosts in v0.4, or only plain TCP/Unix sockets?
   - **Recommendation:** Support basic auth (TCP/Unix) in v0.4, TLS in v0.5

2. **Environment Deletion:** What happens to deployed containers when environment is deleted?
   - **Recommendation:** Prevent deletion if containers exist; require manual cleanup first

3. **Environment Limits:** Should there be a max number of environments per organization?
   - **Recommendation:** No hard limit in v0.4; add if performance issues arise

4. **Wizard Defaults:** Should wizard auto-detect local Docker daemon, or require user input?
   - **Recommendation:** Auto-detect `unix:///var/run/docker.sock` if available, otherwise prompt

---

## Success Criteria

v0.4 is considered complete when:

- ✅ Users can create multiple environments via UI
- ✅ Users can switch between environments using dropdown selector
- ✅ Dashboard/containers/stacks are filtered by active environment
- ✅ Each environment has independent connection strings configuration
- ✅ Each environment connects to a different Docker host
- ✅ Stack deployments are scoped to active environment
- ✅ v0.3 installations automatically migrate to v0.4 with default environment
- ✅ All unit/integration/E2E tests pass
- ✅ Documentation updated (README, CHANGELOG, release notes)

---

## Timeline Estimate

| Phase | Duration | Tasks |
|-------|----------|-------|
| **Design** | 1 week | Finalize API contracts, UI mockups, database schema |
| **Backend** | 2 weeks | Implement EnvironmentService, ConfigStore changes, migration logic |
| **Frontend** | 1 week | Build EnvironmentSelector, Settings page, hook integration |
| **Testing** | 1 week | Unit, integration, E2E tests |
| **Documentation** | 3 days | Update all docs, write migration guide |
| **QA & Bug Fixes** | 1 week | User acceptance testing, polish |

**Total:** ~6 weeks (1.5 months)

---

## References

- [v0.3.0 Release Notes](../Release-Notes/v0.3.0.md)
- [CHANGELOG.md](../../CHANGELOG.md)
- [Docker Engine API](https://docs.docker.com/engine/api/)
- [Clean Architecture Principles](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
