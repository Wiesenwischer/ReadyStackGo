# v0.14 â€“ Stack Upgrade Feature

Spezifikation fÃ¼r das Stack-Upgrade-Feature: In-Place Updates von deployed Stacks.

## Ãœbersicht

| Feature | Scope | PrioritÃ¤t |
|---------|-------|-----------|
| Upgrade Detection | Backend | Hoch |
| Upgrade API | Backend | Hoch |
| Upgrade UI | Frontend | Hoch |
| Variable Migration | Backend | Mittel |
| Upgrade History | Backend + DB | Mittel |

---

## 1. Motivation

FÃ¼r vollstÃ¤ndige Rollback-UnterstÃ¼tzung muss ein Stack aktualisiert werden kÃ¶nnen:
- **Rollback setzt Upgrade voraus**: Ohne Upgrade gibt es keine Snapshots zum ZurÃ¼ckkehren
- **Versionsverwaltung**: User erwarten Stack-Upgrades ohne Datenverlust
- **Continous Delivery**: Automatisierte Pipelines benÃ¶tigen Upgrade-APIs

### Aktueller Stand

Das Backend unterstÃ¼tzt bereits In-Place Upgrades (DeploymentService.cs:693-728):
- `GetWithSnapshotsByStackName()` prÃ¼ft auf bestehende Deployments
- Snapshot wird automatisch vor Upgrade erstellt
- Deployment wird wiederverwendet (erhÃ¤lt Snapshots)

**Was fehlt:**
- UI zum Triggern eines Upgrades
- Versionserkennung (ist Update verfÃ¼gbar?)
- Expliziter Upgrade-Flow (vs. neues Deployment)

---

## 2. Domain Model

### 2.1 Deployment Aggregate Erweiterung

Das Deployment-Aggregate erhÃ¤lt neue Properties fÃ¼r Upgrade-Tracking:

```csharp
public class Deployment : AggregateRoot<DeploymentId>
{
    // Bestehende Properties...

    // NEU: Upgrade-History Tracking
    public DateTime? LastUpgradedAt { get; private set; }
    public string? PreviousVersion { get; private set; }
    public int UpgradeCount { get; private set; } = 0;

    /// <summary>
    /// Records an upgrade event, storing the previous version for reference.
    /// </summary>
    public void RecordUpgrade(string previousVersion, string newVersion)
    {
        PreviousVersion = previousVersion;
        LastUpgradedAt = SystemClock.UtcNow;
        UpgradeCount++;

        AddDomainEvent(new DeploymentUpgraded(
            Id,
            previousVersion,
            newVersion,
            LastUpgradedAt.Value));
    }
}
```

### 2.2 Neues Domain Event

```csharp
// Domain/Deployment/Events/DeploymentUpgraded.cs
public record DeploymentUpgraded(
    DeploymentId DeploymentId,
    string PreviousVersion,
    string NewVersion,
    DateTime UpgradedAt) : IDomainEvent;
```

---

## 3. Application Layer

### 3.1 Use Case: UpgradeStack

Expliziter Upgrade-Use-Case, der den bestehenden Deploy-Flow nutzt aber mit klarer Upgrade-Semantik:

```csharp
// Application/UseCases/Deployments/UpgradeStack/UpgradeStackCommand.cs
public record UpgradeStackCommand(
    string EnvironmentId,
    string DeploymentId,
    string NewStackId,           // CatalogStackId mit neuer Version
    Dictionary<string, string> Variables,
    string? SessionId = null) : IRequest<UpgradeStackResponse>;

public record UpgradeStackResponse
{
    public bool Success { get; init; }
    public string? Message { get; init; }
    public string? DeploymentId { get; init; }
    public string? PreviousVersion { get; init; }
    public string? NewVersion { get; init; }
    public string? SnapshotId { get; init; }
    public List<string>? Errors { get; init; }
}
```

```csharp
// Application/UseCases/Deployments/UpgradeStack/UpgradeStackHandler.cs
public class UpgradeStackHandler : IRequestHandler<UpgradeStackCommand, UpgradeStackResponse>
{
    public async Task<UpgradeStackResponse> Handle(UpgradeStackCommand request, CancellationToken ct)
    {
        // 1. Validate existing deployment
        var deployment = await _deploymentRepository.GetWithSnapshotsAsync(
            new DeploymentId(Guid.Parse(request.DeploymentId)), ct);

        if (deployment == null)
            return UpgradeStackResponse.Failed("Deployment not found");

        if (deployment.Status != DeploymentStatus.Running)
            return UpgradeStackResponse.Failed("Only running deployments can be upgraded");

        // 2. Load new stack version from catalog
        var newStack = await _productSourceService.GetStackAsync(request.NewStackId, ct);
        if (newStack == null)
            return UpgradeStackResponse.Failed($"Stack '{request.NewStackId}' not found");

        // 3. Validate upgrade path (optional: version comparison)
        var previousVersion = deployment.StackVersion;
        var newVersion = newStack.ProductVersion;

        // 4. Create pre-upgrade snapshot
        var snapshot = deployment.CreateSnapshot($"Before upgrade to {newVersion}");
        var snapshotId = snapshot?.Id;

        // 5. Merge variables (keep existing, overlay new)
        var mergedVariables = MergeVariables(
            deployment.Variables,
            request.Variables,
            newStack.Variables);

        // 6. Deploy new version using existing flow
        var deployResult = await _mediator.Send(new DeployStackCommand(
            request.EnvironmentId,
            request.NewStackId,
            deployment.StackName, // Keep same stack name
            mergedVariables,
            request.SessionId), ct);

        if (!deployResult.Success)
        {
            return new UpgradeStackResponse
            {
                Success = false,
                Message = deployResult.Message,
                Errors = deployResult.Errors
            };
        }

        // 7. Record upgrade in deployment
        deployment.RecordUpgrade(previousVersion, newVersion);
        await _deploymentRepository.UpdateAsync(deployment, ct);

        return new UpgradeStackResponse
        {
            Success = true,
            Message = $"Successfully upgraded from {previousVersion} to {newVersion}",
            DeploymentId = request.DeploymentId,
            PreviousVersion = previousVersion,
            NewVersion = newVersion,
            SnapshotId = snapshotId?.Value.ToString()
        };
    }

    /// <summary>
    /// Merges variables from existing deployment with new values and new stack defaults.
    /// Priority: Explicit request > Existing deployment > Stack defaults
    /// </summary>
    private Dictionary<string, string> MergeVariables(
        IReadOnlyDictionary<string, string> existing,
        Dictionary<string, string> requested,
        IReadOnlyList<Variable> stackVariables)
    {
        var merged = new Dictionary<string, string>();

        // Start with stack defaults
        foreach (var v in stackVariables)
        {
            if (!string.IsNullOrEmpty(v.DefaultValue))
                merged[v.Name] = v.DefaultValue;
        }

        // Overlay with existing deployment values
        foreach (var kvp in existing)
            merged[kvp.Key] = kvp.Value;

        // Overlay with explicitly requested values
        foreach (var kvp in requested)
            merged[kvp.Key] = kvp.Value;

        return merged;
    }
}
```

### 3.2 Use Case: CheckUpgradeAvailable

Query zum PrÃ¼fen, ob ein Upgrade verfÃ¼gbar ist:

```csharp
// Application/UseCases/Deployments/CheckUpgrade/CheckUpgradeQuery.cs
public record CheckUpgradeQuery(
    string EnvironmentId,
    string DeploymentId) : IRequest<CheckUpgradeResponse>;

public record CheckUpgradeResponse
{
    public bool Success { get; init; }
    public string? Message { get; init; }

    public bool UpgradeAvailable { get; init; }
    public string? CurrentVersion { get; init; }
    public string? LatestVersion { get; init; }
    public string? LatestStackId { get; init; }

    // NEU: Informationen Ã¼ber die neue Version
    public List<string>? NewVariables { get; init; }      // Neu hinzugefÃ¼gte Variablen
    public List<string>? RemovedVariables { get; init; }  // Entfernte Variablen
    public List<string>? ChangedServices { get; init; }   // GeÃ¤nderte Services
}
```

```csharp
// Application/UseCases/Deployments/CheckUpgrade/CheckUpgradeHandler.cs
public class CheckUpgradeHandler : IRequestHandler<CheckUpgradeQuery, CheckUpgradeResponse>
{
    public async Task<CheckUpgradeResponse> Handle(CheckUpgradeQuery request, CancellationToken ct)
    {
        // 1. Get deployment
        var deployment = await _deploymentRepository.GetAsync(
            new DeploymentId(Guid.Parse(request.DeploymentId)), ct);
        if (deployment == null)
            return new CheckUpgradeResponse { Success = false, Message = "Deployment not found" };

        // 2. Get current catalog stack (by CatalogStackId)
        if (string.IsNullOrEmpty(deployment.CatalogStackId))
            return new CheckUpgradeResponse
            {
                Success = true,
                UpgradeAvailable = false,
                Message = "Deployment was not created from catalog (manual YAML deployment)"
            };

        // 3. Find latest version of this product in catalog
        var productId = ExtractProductId(deployment.CatalogStackId);
        var product = await _productSourceService.GetProductAsync(productId, ct);

        if (product == null)
            return new CheckUpgradeResponse
            {
                Success = true,
                UpgradeAvailable = false,
                Message = "Product no longer available in catalog"
            };

        // 4. Compare versions
        var currentVersion = deployment.StackVersion;
        var latestVersion = product.ProductVersion;

        var upgradeAvailable = CompareVersions(currentVersion, latestVersion) < 0;

        // 5. Analyze changes between versions (if upgrade available)
        List<string>? newVars = null;
        List<string>? removedVars = null;
        if (upgradeAvailable)
        {
            var currentStack = await _productSourceService.GetStackAsync(deployment.CatalogStackId, ct);
            var latestStack = product.DefaultStack;

            (newVars, removedVars) = CompareVariables(
                currentStack?.Variables ?? [],
                latestStack.Variables);
        }

        return new CheckUpgradeResponse
        {
            Success = true,
            UpgradeAvailable = upgradeAvailable,
            CurrentVersion = currentVersion,
            LatestVersion = latestVersion,
            LatestStackId = $"{productId}:{product.DefaultStack.Name}",
            NewVariables = newVars,
            RemovedVariables = removedVars
        };
    }

    /// <summary>
    /// Compares semantic versions. Returns -1 if v1 < v2, 0 if equal, 1 if v1 > v2.
    /// </summary>
    private static int CompareVersions(string? v1, string? v2)
    {
        if (string.IsNullOrEmpty(v1) && string.IsNullOrEmpty(v2)) return 0;
        if (string.IsNullOrEmpty(v1)) return -1;
        if (string.IsNullOrEmpty(v2)) return 1;

        // Try semantic version comparison
        if (Version.TryParse(v1.TrimStart('v', 'V'), out var ver1) &&
            Version.TryParse(v2.TrimStart('v', 'V'), out var ver2))
        {
            return ver1.CompareTo(ver2);
        }

        // Fallback to string comparison
        return string.Compare(v1, v2, StringComparison.OrdinalIgnoreCase);
    }
}
```

---

## 4. API Endpoints

### 4.1 Upgrade Stack

```http
POST /api/environments/{environmentId}/deployments/{deploymentId}/upgrade

Request:
{
  "stackId": "example-stacks:wordpress:default",  // New version's catalog ID
  "variables": {                                   // Optional: override variables
    "MYSQL_ROOT_PASSWORD": "newpassword"
  },
  "sessionId": "optional-client-session"          // For SignalR progress
}

Response (200 OK):
{
  "success": true,
  "message": "Successfully upgraded from 5.9.0 to 6.0.0",
  "deploymentId": "abc-123",
  "previousVersion": "5.9.0",
  "newVersion": "6.0.0",
  "snapshotId": "snap-456"
}

Response (400 Bad Request):
{
  "success": false,
  "message": "Only running deployments can be upgraded",
  "errors": ["Deployment status is 'Failed'"]
}
```

### 4.2 Check Upgrade Available

```http
GET /api/environments/{environmentId}/deployments/{deploymentId}/upgrade/check

Response (200 OK):
{
  "success": true,
  "upgradeAvailable": true,
  "currentVersion": "5.9.0",
  "latestVersion": "6.0.0",
  "latestStackId": "example-stacks:wordpress:default",
  "newVariables": ["NEW_FEATURE_FLAG"],
  "removedVariables": ["DEPRECATED_SETTING"],
  "changedServices": ["web", "worker"]
}
```

### 4.3 Redeploy (Same Version)

FÃ¼r Redeploy ohne Versionswechsel (z.B. nach Config-Ã„nderung):

```http
POST /api/environments/{environmentId}/deployments/{deploymentId}/redeploy

Request:
{
  "variables": {
    "MYSQL_ROOT_PASSWORD": "changedpassword"
  },
  "createSnapshot": true,
  "sessionId": "optional-client-session"
}

Response:
{
  "success": true,
  "message": "Successfully redeployed wordpress",
  "deploymentId": "abc-123",
  "snapshotId": "snap-789"
}
```

---

## 5. Database Schema

### 5.1 Deployment Table Erweiterung

```sql
-- Migration: Add upgrade tracking columns
ALTER TABLE Deployments ADD COLUMN LastUpgradedAt TEXT NULL;
ALTER TABLE Deployments ADD COLUMN PreviousVersion TEXT NULL;
ALTER TABLE Deployments ADD COLUMN UpgradeCount INTEGER NOT NULL DEFAULT 0;
```

### 5.2 EF Core Configuration

```csharp
// Infrastructure.DataAccess/Configurations/DeploymentConfiguration.cs
builder.Property(d => d.LastUpgradedAt);
builder.Property(d => d.PreviousVersion);
builder.Property(d => d.UpgradeCount).HasDefaultValue(0);
```

---

## 6. Frontend UI

### 6.1 Deployment Detail Page - Upgrade Banner

Wenn ein Upgrade verfÃ¼gbar ist, wird ein Banner angezeigt:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â¬†ï¸  Update Available                                        [Dismiss] â”‚
â”‚                                                                      â”‚
â”‚ A new version of WordPress is available:                            â”‚
â”‚ Current: 5.9.0  â†’  Latest: 6.0.0                                    â”‚
â”‚                                                                      â”‚
â”‚ Changes:                                                            â”‚
â”‚ â€¢ 2 new configuration options added                                  â”‚
â”‚ â€¢ 1 deprecated option removed                                        â”‚
â”‚                                                                      â”‚
â”‚                                              [View Details] [Upgrade]â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 Upgrade Dialog

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Upgrade WordPress                                               [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Current Version: 5.9.0                                             â”‚
â”‚  Target Version:  6.0.0                                             â”‚
â”‚                                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                      â”‚
â”‚  ğŸ“¦ Configuration                                                    â”‚
â”‚                                                                      â”‚
â”‚  â”Œâ”€ Existing Variables (preserved) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ WORDPRESS_DB_HOST        mysql                               â”‚   â”‚
â”‚  â”‚ WORDPRESS_DB_NAME        wordpress                           â”‚   â”‚
â”‚  â”‚ WORDPRESS_DB_USER        admin                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚  â”Œâ”€ New Variables (required) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ NEW_CACHE_ENABLED        [x] Enable  [ ] Disable             â”‚   â”‚
â”‚  â”‚ NEW_CACHE_TTL            [________] (default: 3600)          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚  âš ï¸  Removed in this version: OLD_DEPRECATED_SETTING                â”‚
â”‚                                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                      â”‚
â”‚  [x] Create snapshot before upgrade (recommended)                   â”‚
â”‚                                                                      â”‚
â”‚  â„¹ï¸  You can rollback to version 5.9.0 after the upgrade            â”‚
â”‚                                                                      â”‚
â”‚                              [Cancel]  [Start Upgrade]              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.3 Upgrade Progress (via SignalR)

Nutzt das bestehende DeploymentHub fÃ¼r Progress-Updates:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Upgrading WordPress...                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 60%                         â”‚
â”‚                                                                      â”‚
â”‚  âœ“ Created snapshot (5.9.0)                                         â”‚
â”‚  âœ“ Pulled new images                                                â”‚
â”‚  â³ Stopping old containers...                                       â”‚
â”‚  â—‹ Starting new containers                                          â”‚
â”‚  â—‹ Verifying health                                                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.4 Neue Komponenten

| Komponente | Beschreibung |
|------------|--------------|
| `UpgradeBanner.tsx` | Banner auf DeploymentDetail wenn Update verfÃ¼gbar |
| `UpgradeDialog.tsx` | Modal-Dialog fÃ¼r Upgrade-Konfiguration |
| `VariableMigration.tsx` | Zeigt neue/entfernte Variablen |
| `UpgradeProgress.tsx` | SignalR-basierte Progress-Anzeige |

### 6.5 API Client Erweiterung

```typescript
// api/deployments.ts

export interface UpgradeCheckResponse {
  success: boolean;
  message?: string;
  upgradeAvailable: boolean;
  currentVersion?: string;
  latestVersion?: string;
  latestStackId?: string;
  newVariables?: string[];
  removedVariables?: string[];
}

export interface UpgradeRequest {
  stackId: string;
  variables?: Record<string, string>;
  sessionId?: string;
}

export interface UpgradeResponse {
  success: boolean;
  message?: string;
  deploymentId?: string;
  previousVersion?: string;
  newVersion?: string;
  snapshotId?: string;
  errors?: string[];
}

export async function checkUpgrade(
  environmentId: string,
  deploymentId: string
): Promise<UpgradeCheckResponse> {
  return client.get(`/environments/${environmentId}/deployments/${deploymentId}/upgrade/check`);
}

export async function upgradeDeployment(
  environmentId: string,
  deploymentId: string,
  request: UpgradeRequest
): Promise<UpgradeResponse> {
  return client.post(
    `/environments/${environmentId}/deployments/${deploymentId}/upgrade`,
    request
  );
}
```

---

## 7. Upgrade-Strategien

### 7.1 Standard-Upgrade (In-Place)

```
1. Snapshot erstellen
2. Neue Images pullen
3. Alte Container stoppen
4. Neue Container starten (selbe Volumes, Networks)
5. Health-Check abwarten
6. Status auf Running setzen
```

**Vorteile:**
- Einfach zu implementieren
- Volumes bleiben erhalten
- Schnell

**Nachteile:**
- Kurze Downtime wÃ¤hrend Container-Wechsel
- Kein Zero-Downtime mÃ¶glich

### 7.2 Recreate-Upgrade

Wie Standard, aber Container werden neu erstellt (nicht nur gestoppt/gestartet):

```
docker-compose up -d --force-recreate
```

### 7.3 Rolling Upgrade (Future: Post v1.0)

FÃ¼r Multi-Replica Services:

```
1. Service 1/3 stoppen, neu starten, Health-Check
2. Service 2/3 stoppen, neu starten, Health-Check
3. Service 3/3 stoppen, neu starten, Health-Check
```

---

## 8. Error Handling

### 8.1 Upgrade-Fehler

| Fehler | Handling |
|--------|----------|
| Image Pull fehlgeschlagen | Abbruch, keine Ã„nderungen, Rollback mÃ¶glich |
| Container Start fehlgeschlagen | Kein Rollback mehr (Point of No Return Ã¼berschritten) |
| Health-Check fehlgeschlagen | Kein Rollback (Container laufen bereits) |
| Snapshot-Erstellung fehlgeschlagen | Warnung, Upgrade fortsetzen |

### 8.2 Point of No Return

Ab dem Moment, in dem Container gestartet werden, ist kein automatischer Rollback mehr mÃ¶glich:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Upgrade v1.0 â†’ v2.0                                             â”‚
â”‚                                                                 â”‚
â”‚ 1. [ ] Validate neue Version            â”€â”                      â”‚
â”‚ 2. [ ] Create Snapshot                   â”‚  Rollback mÃ¶glich    â”‚
â”‚ 3. [ ] Stop alte Container               â”‚  bei Fehler          â”‚
â”‚ 4. [ ] Pull neue Images                 â”€â”˜                      â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ 5. [ ] Start Container                  â† POINT OF NO RETURN    â”‚
â”‚ 6. [ ] Health Check                                             â”‚
â”‚                                                                 â”‚
â”‚ Ab Schritt 5: Kein Rollback mehr mÃ¶glich                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**BegrÃ¼ndung:** Sobald Container gestartet werden, kÃ¶nnen irreversible Ã„nderungen stattfinden (DB-Migrationen, Init-Container etc.). Ein automatisches Rollback wÃ¤re in diesem Fall gefÃ¤hrlich.

---

## 9. Implementierungsreihenfolge

### Phase 1: Backend (PrioritÃ¤t Hoch)
1. Domain Model erweitern (`LastUpgradedAt`, `PreviousVersion`, `UpgradeCount`)
2. Domain Event `DeploymentUpgraded` erstellen
3. `CheckUpgradeQuery/Handler` implementieren
4. `UpgradeStackCommand/Handler` implementieren
5. API Endpoints hinzufÃ¼gen
6. EF Core Migration erstellen

### Phase 2: Frontend (PrioritÃ¤t Hoch)
1. API Client erweitern
2. `UpgradeBanner.tsx` implementieren (fÃ¼r DeploymentDetail)
3. `UpgradeDialog.tsx` implementieren
4. `VariableMigration.tsx` fÃ¼r Variable-Diff
5. Integration in DeploymentDetailPage

### Phase 3: Polish (PrioritÃ¤t Mittel)
1. `UpgradeProgress.tsx` mit SignalR
2. Automatischer Rollback bei Fehler
3. Upgrade-History in UI anzeigen

---

## 10. Tests

### Unit Tests
- `UpgradeStackHandlerTests.cs` - Happy path, Fehler-Cases
- `CheckUpgradeHandlerTests.cs` - Version comparison, edge cases
- `DeploymentUpgradeTests.cs` - Domain model upgrade recording

### Integration Tests
- Upgrade E2E mit Docker TestContainers
- API Endpoint Tests
- Variable migration tests

### Frontend Tests
- UpgradeBanner rendering based on state
- UpgradeDialog form validation
- Progress updates via SignalR

---

## 11. Nicht im Scope

Folgende Features werden auf spÃ¤tere Versionen verschoben:

- **Rolling Upgrades** (Multi-Replica) â†’ Post v1.0
- **Blue/Green Deployments** â†’ Post v1.0
- **Canary Deployments** â†’ Post v1.0
- **Automatic Upgrades** (GitOps) â†’ v0.19 (CI/CD Integration)
- **Upgrade Approval Workflow** â†’ Post v1.0
- **Downgrade Protection** (nur hÃ¶here Versionen erlauben) â†’ Optional

---

## 12. AbhÃ¤ngigkeiten

### Voraussetzungen
- v0.13 Health Monitoring (fÃ¼r Health-Checks nach Upgrade)
- v0.14 Rollback Feature (fÃ¼r Snapshot-Erstellung)

### Keine neuen NuGet/NPM Packages erforderlich

Das Feature nutzt existierende Infrastruktur:
- MediatR fÃ¼r CQRS
- SignalR fÃ¼r Progress
- EF Core fÃ¼r Persistence

---

## 13. Design-Entscheidungen

### 13.1 Kein Downgrade Support

**Entscheidung:** Downgrades werden fÃ¼r v1 nicht unterstÃ¼tzt. Nur Upgrades auf neuere Versionen sind erlaubt.

**BegrÃ¼ndung:**
- Vereinfacht die Implementierung erheblich
- Vermeidet DB-InkompatibilitÃ¤ten (Ã¤lterer Code mit neuerem Schema)
- Klare Upgrade-Richtung: nur vorwÃ¤rts
- Rollback (via Snapshot) deckt den "zurÃ¼ck"-Fall ab

**Implementierung:**
```csharp
// Im UpgradeStackHandler
var comparison = VersionComparer.Compare(currentVersion, newVersion);

if (comparison == null)
{
    return UpgradeStackResponse.Failed(
        "Version comparison not possible. Ensure both versions use SemVer format.");
}

if (comparison >= 0) // Same version or downgrade
{
    return UpgradeStackResponse.Failed(
        comparison == 0
            ? $"Already running version {currentVersion}"
            : $"Downgrade from {currentVersion} to {newVersion} is not supported. Use rollback instead.");
}
```

**UI:** Im Upgrade-Dialog werden nur neuere Versionen als Ziel angeboten. Ã„ltere Versionen werden nicht angezeigt.

### 13.2 Concurrency: Environment-Level Blocking

**Entscheidung:** Pro Environment kann nur eine Operation (Deploy/Upgrade/Remove) gleichzeitig laufen. Keine Queue, sondern Blocking mit Fehlermeldung.

**BegrÃ¼ndung:**
- Einfach zu implementieren
- Verhindert Race Conditions bei Container-Operationen
- Admin kann stuck Operations freigeben
- Queue wÃ¤re fÃ¼r v1 zu komplex

**Domain Model Erweiterung:**
```csharp
// Domain/Deployment/Environments/Environment.cs
public class Environment : AggregateRoot<EnvironmentId>
{
    // Bestehende Properties...

    public bool IsBusy { get; private set; }
    public string? CurrentOperation { get; private set; }
    public DateTime? OperationStartedAt { get; private set; }

    /// <summary>
    /// Starts an operation on this environment.
    /// Throws if another operation is already running.
    /// </summary>
    public void StartOperation(string operationDescription)
    {
        SelfAssertState(!IsBusy,
            $"Environment is busy: {CurrentOperation}");

        IsBusy = true;
        CurrentOperation = operationDescription;
        OperationStartedAt = SystemClock.UtcNow;
    }

    /// <summary>
    /// Marks the current operation as complete.
    /// </summary>
    public void CompleteOperation()
    {
        IsBusy = false;
        CurrentOperation = null;
        OperationStartedAt = null;
    }

    /// <summary>
    /// Force-releases a stuck operation. Admin function.
    /// </summary>
    public void ForceReleaseOperation()
    {
        if (IsBusy)
        {
            AddDomainEvent(new OperationForceReleased(Id, CurrentOperation));
        }
        CompleteOperation();
    }

    /// <summary>
    /// Checks if the current operation has exceeded the timeout.
    /// </summary>
    public bool IsOperationStuck(TimeSpan timeout)
    {
        return IsBusy &&
               OperationStartedAt.HasValue &&
               (SystemClock.UtcNow - OperationStartedAt.Value) > timeout;
    }
}
```

**API Response bei Busy Environment:**
```json
{
  "success": false,
  "message": "Environment is busy",
  "error": {
    "code": "ENVIRONMENT_BUSY",
    "currentOperation": "Deploying wordpress",
    "startedAt": "2025-12-15T14:30:00Z"
  }
}
```

**UI bei Busy Environment:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â³ Environment Busy                                                  â”‚
â”‚                                                                      â”‚
â”‚ Another operation is in progress:                                   â”‚
â”‚ "Deploying wordpress" (started 2 minutes ago)                       â”‚
â”‚                                                                      â”‚
â”‚ Please wait for completion or contact an admin.                     â”‚
â”‚                                          [Refresh] [Force Release*] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
* Only visible for admins, after timeout (default: 10 minutes)
```

**Database Schema:**
```sql
ALTER TABLE Environments ADD COLUMN IsBusy INTEGER NOT NULL DEFAULT 0;
ALTER TABLE Environments ADD COLUMN CurrentOperation TEXT NULL;
ALTER TABLE Environments ADD COLUMN OperationStartedAt TEXT NULL;
```

### 13.3 Versionierung: SemVer Only

**Entscheidung:** FÃ¼r v1 wird ausschlieÃŸlich Semantic Versioning unterstÃ¼tzt. Non-SemVer Versionen werden mit Warnung akzeptiert, aber Upgrade-Detection funktioniert nicht.

**BegrÃ¼ndung:**
- Klare Regeln fÃ¼r Version-Vergleich
- Einfache Implementierung
- Standard in der Branche

**Implementierung:**
```csharp
public static class VersionComparer
{
    /// <summary>
    /// Compares two SemVer versions.
    /// Returns: -1 (v1 &lt; v2), 0 (equal), 1 (v1 &gt; v2)
    /// Returns null if either version is not valid SemVer.
    /// </summary>
    public static int? Compare(string? v1, string? v2)
    {
        if (!TryParseSemVer(v1, out var ver1) ||
            !TryParseSemVer(v2, out var ver2))
        {
            return null;
        }

        return ver1.CompareTo(ver2);
    }

    public static bool IsUpgrade(string? current, string? target)
    {
        var comparison = Compare(current, target);
        return comparison.HasValue && comparison.Value < 0;
    }

    public static bool IsDowngrade(string? current, string? target)
    {
        var comparison = Compare(current, target);
        return comparison.HasValue && comparison.Value > 0;
    }

    public static bool IsSameVersion(string? v1, string? v2)
    {
        var comparison = Compare(v1, v2);
        return comparison.HasValue && comparison.Value == 0;
    }

    private static bool TryParseSemVer(string? version, out Version result)
    {
        result = null!;
        if (string.IsNullOrEmpty(version))
            return false;

        // Normalize: remove 'v' prefix
        var normalized = version.TrimStart('v', 'V');
        return Version.TryParse(normalized, out result!);
    }
}
```

**Validierung beim Product-Import:**
```csharp
// Im LocalDirectoryProductSourceProvider
if (!string.IsNullOrEmpty(manifest.Metadata?.ProductVersion))
{
    if (!VersionComparer.TryParseSemVer(manifest.Metadata.ProductVersion, out _))
    {
        _logger.LogWarning(
            "Product {Name} has non-SemVer version '{Version}'. " +
            "Upgrade detection will not work for this product.",
            manifest.Metadata.Name,
            manifest.Metadata.ProductVersion);
    }
}
```

**UI-Verhalten bei Non-SemVer:**
- Kein "Upgrade Available" Banner
- Manuelles Upgrade Ã¼ber Catalog mÃ¶glich
- Warnung: "Version comparison not available (non-SemVer format)"

---

### 13.4 Rollback = Manueller Recovery vor Container-Start

**Entscheidung:** Rollback ist nur mÃ¶glich wenn das Upgrade **vor** dem Container-Start fehlgeschlagen ist. Der User muss Rollback manuell triggern.

**BegriffsklÃ¤rung:**
| Begriff | Bedeutung | UnterstÃ¼tzt |
|---------|-----------|-------------|
| **Rollback** | Recovery nach fehlgeschlagenem Upgrade (vor Container-Start) | Ja, manuell |
| **Downgrade** | Bewusste Wahl einer Ã¤lteren Version | Nein (v1) |

**BegrÃ¼ndung:**
- Klare Semantik: Rollback = Recovery bei Fehler in frÃ¼hen Upgrade-Phasen
- Sicherer "Point of No Return": Sobald Container gestartet wurden, ist Rollback nicht mehr mÃ¶glich
- User behÃ¤lt Kontrolle (manueller Trigger)
- Vermeidet komplexe Logik fÃ¼r Migration-Container und DB-Ã„nderungen

**Rollback-Flow:**
```
v1.0 (initial deploy)     â†’ Kein Rollback mÃ¶glich (kein Snapshot)
     â†“ Upgrade
     [Image Pull FAILED]  â†’ Rollback zu v1.0 mÃ¶glich (manuell)
     â†“ User klickt Rollback
v1.0 wiederhergestellt    â†’ Snapshot gelÃ¶scht
```

```
v1.0 (initial deploy)     â†’ Kein Rollback mÃ¶glich (kein Snapshot)
     â†“ Upgrade
     [Container Start OK] â†’ POINT OF NO RETURN Ã¼berschritten
v1.1 (Running)            â†’ Kein Rollback mehr mÃ¶glich
```

**Wann Rollback verfÃ¼gbar ist:**
- Upgrade wurde gestartet und Snapshot erstellt
- Upgrade ist in Phase 1-4 fehlgeschlagen (Validation, Snapshot, Stop, Pull)
- User klickt manuell "Rollback" Button

**Wann Rollback NICHT verfÃ¼gbar ist:**
- Initial-Deployment (kein Snapshot)
- Container wurden bereits gestartet (Phase 5+)
- Upgrade erfolgreich abgeschlossen

**UI bei fehlgeschlagenem Upgrade (vor Container-Start):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ Upgrade Failed                                                    â”‚
â”‚                                                                      â”‚
â”‚ Upgrade to v2.0 failed: Image 'myapp:2.0' not found                 â”‚
â”‚                                                                      â”‚
â”‚ Previous version v1.1 is available for rollback.                    â”‚
â”‚                                                                      â”‚
â”‚                    [View Logs]  [Retry]  [Rollback to v1.1]         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**UI bei fehlgeschlagenem Upgrade (nach Container-Start):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âŒ Upgrade Failed                                                    â”‚
â”‚                                                                      â”‚
â”‚ Upgrade to v2.0 failed: Container 'api' health check failed         â”‚
â”‚                                                                      â”‚
â”‚ âš ï¸ Rollback not available - containers were already started.        â”‚
â”‚    Please investigate logs or deploy a different version.           â”‚
â”‚                                                                      â”‚
â”‚                              [View Logs]  [Deploy Different Version]â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementierung im Upgrade-Handler:**
```csharp
public async Task<UpgradeStackResponse> Handle(UpgradeStackCommand request, CancellationToken ct)
{
    // 1. Snapshot erstellen (vor Upgrade)
    var snapshot = deployment.CreateSnapshot($"Before upgrade to {newVersion}");

    // 2. Pre-Container Phases (Validation, Stop, Pull)
    var preResult = await ExecutePreContainerPhases(plan);
    if (!preResult.Success)
    {
        // Fehler vor Container-Start â†’ Snapshot behalten fÃ¼r manuellen Rollback
        deployment.MarkAsFailed(preResult.Message);
        await _deploymentRepository.UpdateAsync(deployment, ct);

        return UpgradeStackResponse.Failed(
            preResult.Message,
            canRollback: snapshot != null,
            rollbackVersion: snapshot?.StackVersion);
    }

    // 3. POINT OF NO RETURN: Container starten
    deployment.ClearSnapshot(); // Ab hier kein Rollback mehr
    await _deploymentRepository.UpdateAsync(deployment, ct);

    var startResult = await StartContainers(plan);
    if (!startResult.Success)
    {
        deployment.MarkAsFailed(startResult.Message);
        await _deploymentRepository.UpdateAsync(deployment, ct);

        // Kein Rollback mÃ¶glich - Container wurden bereits gestartet
        return UpgradeStackResponse.Failed(
            startResult.Message,
            canRollback: false);
    }

    return UpgradeStackResponse.Success(...);
}
```

**Domain Model:**
```csharp
public class Deployment : AggregateRoot<DeploymentId>
{
    // Snapshot wird nur wÃ¤hrend Upgrade gehalten (bis Container-Start)
    public DeploymentSnapshot? PendingUpgradeSnapshot { get; private set; }

    public DeploymentSnapshot? CreateSnapshot(string? description = null)
    {
        PendingUpgradeSnapshot = new DeploymentSnapshot { ... };
        return PendingUpgradeSnapshot;
    }

    public void RollbackToPrevious()
    {
        SelfAssertState(PendingUpgradeSnapshot != null,
            "No snapshot available for rollback.");
        SelfAssertState(Status == DeploymentStatus.Failed,
            "Rollback only available after failed upgrade (before container start)");

        // Restore from snapshot
        StackVersion = PendingUpgradeSnapshot.StackVersion;
        _variables.Clear();
        foreach (var (key, value) in PendingUpgradeSnapshot.Variables)
            _variables[key] = value;

        var snapshotId = PendingUpgradeSnapshot.Id;
        PendingUpgradeSnapshot = null;

        AddDomainEvent(new DeploymentRolledBack(Id, snapshotId, StackVersion));
    }

    public void ClearSnapshot()
    {
        // Point of No Return erreicht oder Upgrade erfolgreich
        PendingUpgradeSnapshot = null;
    }

    public bool CanRollback()
    {
        return PendingUpgradeSnapshot != null &&
               Status == DeploymentStatus.Failed;
    }
}
```

**API:**
```http
# Rollback nach fehlgeschlagenem Upgrade (manuell)
POST /api/environments/{environmentId}/deployments/{deploymentId}/rollback

Response (Erfolg):
{
  "success": true,
  "message": "Rolled back from 2.0.0 to 1.1.0",
  "restoredVersion": "1.1.0"
}

Response (Fehler - kein Snapshot):
{
  "success": false,
  "message": "Rollback not available - containers were already started"
}

Response (Fehler - kein Failed-Status):
{
  "success": false,
  "message": "Rollback only available after failed upgrade"
}
```

---

## 14. Offene Fragen (GeklÃ¤rt)

| Frage | Entscheidung |
|-------|--------------|
| Version-Vergleich | SemVer only fÃ¼r v1 |
| Downgrade erlaubt? | Nein, nicht unterstÃ¼tzt fÃ¼r v1 |
| Rollback wann? | Nur wenn Upgrade vor Container-Start fehlgeschlagen ist |
| Manueller Rollback? | Ja, User triggert manuell (kein Auto-Rollback) |
| Concurrent Upgrades | Environment-Level Blocking (keine Queue) |
| Catalog-Sync | AuÃŸerhalb Scope dieser Spec (bestehendes Verhalten)
